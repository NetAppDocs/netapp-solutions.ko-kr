---
sidebar: sidebar 
permalink: data-analytics/confluent-kafka-sizing.html 
keywords: solution, architecture, details, hardware, software 
summary: 이 섹션에서는 Confluent 인증에 사용되는 하드웨어 및 소프트웨어에 대해 다룹니다. 이 정보는 NetApp 스토리지를 사용하는 Kafka 구축에 적용할 수 있습니다. 
---
= 사이징
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ./../media/


link:confluent-kafka-best-practice-guidelines.html["이전: 모범 사례 지침."]

Kafka 사이징은 단순, 세분화, 역방향 및 파티션의 4가지 구성 모드로 수행할 수 있습니다.



== 단순함

단순 모드는 최초 Apache Kafka 사용자 또는 초기 상태 사용 사례에 적합합니다. 이 모드에서는 처리량 MBps, 읽기 팬아웃, 보존 및 리소스 사용률(기본값 60%)과 같은 요구 사항을 제공합니다. 또한 온프레미스(베어 메탈, VMware, Kubernetes 또는 OpenStack) 또는 클라우드와 같은 환경에 진입할 수 있습니다. 이 정보를 바탕으로 Kafka 클러스터의 크기를 조정하면 브로커, zookeeper, Apache Kafka 연결 작업자, 스키마 레지스트리, REST 프록시, ksqlDB 및 Confluorent 제어 센터에 필요한 서버 수가 제공됩니다.

계층형 스토리지의 경우 Kafka 클러스터의 크기를 조정할 수 있는 세분화된 구성 모드를 고려해 보십시오. 세밀한 모드는 숙련된 Apache Kafka 사용자나 잘 정의된 사용 사례에 적합합니다. 이 섹션에서는 생산자, 스트림 프로세서 및 소비자를 위한 크기를 조정하는 방법에 대해 설명합니다.



=== 프로듀서

Apache Kafka의 생산자(예: 네이티브 클라이언트, REST 프록시 또는 Kafka 커넥터)를 설명하기 위해 다음 정보를 제공합니다.

* * 이름. * Spark.
* * Producer type. * 응용 프로그램 또는 서비스, 프록시(RDBMS, MQTT, 기타) 및 기존 데이터베이스(RDBMS, NoSQL, 기타). "모름"을 선택할 수도 있습니다.
* * 초당 이벤트 수 평균 처리량 * (예: 1,000,000).
* * 최대 처리량 * 초당 이벤트 수(예: 4,000,000).
* * 평균 메시지 크기. * (바이트), 압축되지 않음(예: 최대 1MB, 1000).
* * 메시지 형식. * 옵션은 Avro, JSON, 프로토콜 버퍼, 바이너리, 텍스트, “잘 모르겠군요.” 및 기타.
* * 복제 계수. * 옵션은 1, 2, 3(Confluent recommendation), 4, 5, 또는 6.
* * 보존 시간. * 1일(예:) 데이터를 Apache Kafka에 얼마나 오랫동안 저장하기를 원하십니까? 무한 시간 동안 임의의 단위로 -1을 입력합니다. 이 계산기는 보존 기간이 10년으로 무한 경우를 가정합니다.
* "Enable Tiered Storage to Decrease Broker Count and Allow for Infinite Storage?" 확인란을 선택합니다.
* 계층형 스토리지를 사용하는 경우 보존 필드는 브로커에 로컬로 저장된 데이터의 핫 세트를 제어합니다. 아카이브 보존 필드는 아카이브 오브젝트 스토리지에 데이터가 저장되는 기간을 제어합니다.
* * 아카이브 스토리지 보존. * 1년(예:) 아카이브 스토리지에 데이터를 얼마나 오랫동안 저장하려는 경우 무한 기간 동안 임의의 단위로 -1을 입력합니다. 이 계산기는 무한 보존을 위해 10년을 유지하는 것으로 가정합니다.
* * Growth Multiplier. * 1(예:) 이 매개 변수의 값이 현재 처리량을 기반으로 하는 경우 1로 설정합니다. 추가 성장에 따라 크기를 조정하려면 이 매개 변수를 성장 배수로 설정합니다.
* * 생산자 인스턴스 수. * 10(예:) 얼마나 많은 프로듀서 인스턴스가 실행됩니까? 이 입력은 CPU 부하를 사이징 계산에 통합하기 위해 필요합니다. 빈 값은 CPU 로드가 계산에 포함되지 않았음을 나타냅니다.


이 예제 입력에 따라 크기를 조정하면 생산자에 다음과 같은 영향을 줍니다.

* 압축되지 않은 바이트의 평균 처리량: 1Gbps. 압축되지 않은 바이트 단위의 최대 처리량: 4Gbps. 압축된 바이트의 평균 처리량: 400Mbps 압축된 바이트 단위의 최대 처리량: 1.6GBps. 이 값은 기본 60% 압축률을 기반으로 합니다(이 값은 변경할 수 있음).
+
** 필요한 총 온브로커 핫 세트 스토리지 수: 31,104TB(복제 포함), 압축. 총 비브로커 아카이브 스토리지 필요: 378,432TB, 압축. 사용 link:https://fusion.netapp.com["https://fusion.netapp.com"^] StorageGRID 사이징:




스트림 프로세서는 아파치 Kafka로부터 데이터를 소비하고 아파치 Kafka로 다시 생산하는 애플리케이션 또는 서비스를 설명해야 합니다. 대부분의 경우 ksqlDB 또는 Kafka 스트림에 빌드됩니다.

* * 이름. * Spark streamer.
* * 처리 시간. * 이 프로세서는 단일 메시지를 처리하는 데 얼마나 걸립니까?
+
** 1ms(단순한 상태 비저장 변환) [예], 10ms(Stateful 인메모리 작업).
** 100ms(stateful 네트워크 또는 디스크 작동), 1000ms(타사 REST 호출)
** 이 매개 변수를 벤치마킹하고 시간이 얼마나 걸리는지 정확히 알고 있습니다.


* * 출력 보존. * 1일(예) 스트림 프로세서는 Apache Kafka로 출력을 다시 생성합니다. 이 출력 데이터를 Apache Kafka에 얼마나 오랫동안 저장하기를 원하십니까? 무한 기간 동안 임의의 단위로 -1을 입력합니다.
* "계층 스토리지를 사용하여 브로커 수를 줄이고 무한 확장 스토리지를 허용하시겠습니까?" 확인란을 선택합니다.
* * 아카이브 스토리지 보존. * 1년(예:) 아카이브 스토리지에 데이터를 얼마나 오랫동안 저장하려는 경우 무한 기간 동안 임의의 단위로 -1을 입력합니다. 이 계산기는 무한 보존을 위해 10년을 유지하는 것으로 가정합니다.
* * 출력 통과 백분율. * 100(예:) 스트림 프로세서는 Apache Kafka로 출력을 다시 생성합니다. Apache Kafka로 다시 출력되는 인바운드 처리량의 비율은 얼마입니까? 예를 들어, 인바운드 처리량이 20Mbps이고 이 값이 10이면 출력 처리량은 2Mbps입니다.
* 어떤 응용 프로그램에서 이 정보를 읽습니까? 프로듀서 유형 기반 사이징에 사용되는 이름인 “Spark”를 선택합니다. 위의 입력을 기반으로 스트림 프로세스 인스턴스 및 주제 파티션 예상에 대한 사이징의 영향을 예상할 수 있습니다.
* 이 스트림 프로세서 응용 프로그램에는 다음과 같은 수의 인스턴스가 필요합니다. 들어오는 항목에는 이러한 많은 파티션이 필요할 수 있습니다. 이 매개 변수를 확인하려면 Confluent에 문의하십시오.
+
** 성장 승수가 없는 평균 처리량에 대해 1,000개
** 최대 처리량에 대해 4,000(성장 승수 없음)
** 성장 승수가 포함된 평균 처리량의 경우 1,000개
** 최대 처리량에 대해 4,000(성장 승수 포함)






=== 소비자

Apache Kafka의 데이터를 사용하고 Apache Kafka로 다시 생성하지 않는 애플리케이션 또는 서비스(예: 네이티브 클라이언트 또는 Kafka Connector)에 대해 설명하십시오.

* * 이름. * Spark 소비자.
* * 처리 시간. * 이 소비자는 단일 메시지를 처리하는 데 얼마나 걸립니까?
+
** 1ms(예: 로깅 같은 간단하고 상태 비저장 작업)
** 10ms(데이터 저장소에 대한 빠른 쓰기)
** 100ms(데이터 저장소에 대한 느린 쓰기)
** 1000ms(타사 휴면 통화)
** 알려진 기간의 다른 벤치마크 프로세스


* * 소비자 유형. * 기존 데이터 저장소(RDBMS, NoSQL, 기타)에 대한 애플리케이션, 프록시 또는 싱크
* 어떤 응용 프로그램에서 이 정보를 읽습니까? 이 매개 변수를 이전에 결정된 생산자 및 스트림 사이징에 연결합니다.


위의 입력 내용에 따라 소비자 인스턴스 및 주제 파티션 추정치에 대한 사이징을 결정해야 합니다. 소비자 응용 프로그램에는 다음과 같은 수의 인스턴스가 필요합니다.

* 평균 처리량에 대해 2,000개, 성장 승수 없음
* 최대 처리량에 대해 8,000개, 성장 승수 없음
* 성장 승수를 포함한 평균 처리량에 대해 2,000개
* 성장 승수를 포함한 최대 처리량에 대해 8,000개


들어오는 주제에는 이 수의 파티션도 필요할 것입니다. 확인하려면 Confluent에 문의하십시오.

생산자, 스트림 프로세서 및 소비자에 대한 요구 사항 외에도 다음과 같은 추가 요구 사항을 제공해야 합니다.

* * 재생성 시간. * 예: 4시간. Apache Kafka 브로커 호스트에 장애가 발생하고 데이터가 손실되며 장애가 발생한 호스트를 대체하기 위해 새 호스트를 프로비저닝하는 경우 이 새 호스트 재구축 속도는 얼마나 빨라야 합니까? 값을 알 수 없는 경우 이 매개 변수를 비워 둡니다.
* * 리소스 활용률 목표(백분율) * 예: 60. 평균 처리량 중에 호스트를 얼마나 활용하기를 원하십니까? Confluent는 Confluent 셀프 밸런싱 클러스터를 사용하고 있지 않는 한 60%의 사용률을 권장합니다. 이 경우 활용률이 더 높을 수 있습니다.




=== 환경에 대해 설명하십시오

* * 클러스터가 어떤 환경에서 실행됩니까? * Amazon Web Services, Microsoft Azure, Google 클라우드 플랫폼, 베어 메탈 온프레미스, VMware 온프레미스, 사내에 OpenStack 또는 온프레미스에 Kubernates가 있습니까?
* * 호스트 세부 정보. * 코어 수: 48(예:), 네트워크 카드 유형(10GbE, 40GbE, 16GbE, 1GbE 또는 다른 유형).
* * 스토리지 볼륨. * 호스트: 12(예:) 호스트당 지원되는 하드 드라이브 또는 SSD 수는 몇 개입니까? Confluent는 호스트당 12개의 하드 드라이브를 권장합니다.
* * 스토리지 용량/볼륨(GB). * 1000(예:) 단일 볼륨에서 몇 기가바이트의 스토리지를 저장할 수 있습니까? Confluent에서는 1TB 디스크를 권장합니다.
* * 스토리지 구성. * 스토리지 볼륨은 어떻게 구성됩니까? Confluent는 Raid10에서 모든 Confluent 기능을 이용할 것을 권장합니다. JBOD, SAN, RAID 1, RAID 0, RAID 5, 및 기타 유형도 지원됩니다.
* * 단일 볼륨 처리량(Mbps). * 125(예:) 단일 스토리지 볼륨이 초당 메가바이트 단위로 읽거나 쓸 수 있는 속도는 얼마나 됩니까? Confluent는 일반적으로 125MBps 처리량의 표준 하드 드라이브를 권장합니다.
* * 메모리 용량(GB). * 64(예:)


환경 변수를 결정한 후 클러스터 크기를 선택합니다. 위에 표시된 예시 매개 변수를 토대로 Confluent Kafka에 대한 다음 사이징을 결정했습니다.

* * 아파치 Kafka. * 브로커 수: 22. 클러스터가 스토리지에 바인딩되어 있습니다. 호스트 수를 줄이고 무한 스토리지를 허용하도록 계층형 스토리지를 설정하는 것이 좋습니다.
* * Apache ZooKeeper. * Count:5; Apache Kafka Connect 작업자: Count:2; Schema Registry: Count:2; REST Proxy: Count:2; ksqlDB:Count:2; Confluorent Control Center: Count:1.


사용 사례를 염두에 두고 플랫폼 팀에 리버스 모드를 사용합니다. 파티션 모드를 사용하여 단일 항목에 필요한 파티션 수를 계산합니다. 을 참조하십시오 https://eventsizer.io[] 역 및 파티션 모드에 따른 크기 조정.

link:confluent-kafka-conclusion.html["다음: 결론."]
