---
sidebar: sidebar 
permalink: data-analytics/confluent-kafka-technology-overview.html 
keywords: storagegrid, apache, confluent, kafka, grid manager, 
summary: 이 섹션에서는 이 솔루션에 사용된 기술에 대해 설명합니다. 
---
= 기술 개요
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ./../media/


[role="lead"]
이 섹션에서는 이 솔루션에 사용된 기술에 대해 설명합니다.



== NetApp StorageGRID를 참조하십시오

NetApp StorageGRID는 비용 효율적인 고성능 오브젝트 스토리지 플랫폼입니다. 계층형 스토리지를 사용하면 중개인의 로컬 스토리지 또는 SAN 스토리지에 저장된 Confluent Kafka의 데이터 대부분이 원격 오브젝트 저장소로 오프로드됩니다. 이 구성은 클러스터 재조정, 확장 또는 축소 또는 실패한 브로커 교체에 드는 시간과 비용을 줄여 운영 효율성을 크게 개선합니다. 오브젝트 스토리지는 오브젝트 저장소 계층에 있는 데이터를 관리하는 데 중요한 역할을 합니다. 따라서 적합한 오브젝트 스토리지를 선택하는 것이 중요합니다.

StorageGRID는 분산된 노드 기반 그리드 아키텍처를 사용하여 정책 중심의 지능형 글로벌 데이터 관리를 제공합니다. 정교한 데이터 관리 기능과 결합된 유비쿼터스 글로벌 오브젝트 네임스페이스를 통해 페타바이트 단위의 비정형 데이터와 수십억 개의 오브젝트 관리를 간소화합니다. 단일 호출 개체 액세스는 사이트 간에 확장되고 고가용성 아키텍처를 단순화하는 동시에 사이트 또는 인프라 중단과 관계없이 지속적인 개체 액세스를 보장합니다.

멀티 테넌시를 사용하면 동일한 그리드 내에서 여러 비정형 클라우드 및 엔터프라이즈 데이터 애플리케이션을 안전하게 서비스할 수 있으므로 NetApp StorageGRID의 ROI 및 사용 사례가 증가합니다. 여러 지역에서 내구성, 보호, 성능, 인접성을 최적화하여 메타데이터 기반 오브젝트 라이프사이클 정책을 통해 여러 서비스 레벨을 생성할 수 있습니다. 사용자는 데이터 관리 정책을 조정하고 트래픽 제한을 모니터링 및 적용하여 끊임없이 변화하는 IT 환경에서 요구 사항이 변경됨에 따라 데이터 환경을 중단 없이 다시 조정할 수 있습니다.



=== Grid Manager를 통한 간편한 관리

StorageGRID 그리드 관리자는 브라우저 기반의 그래픽 인터페이스로, 단일 창에서 전세계에 분산된 위치에 걸쳐 StorageGRID 시스템을 구성, 관리 및 모니터링할 수 있습니다.

image::confluent-kafka-image4.png[통합된 Kafka 이미지4]

StorageGRID 그리드 관리자 인터페이스를 사용하여 다음 작업을 수행할 수 있습니다.

* 이미지, 비디오, 레코드 등 전 세계에 분산된 페타바이트 규모의 오브젝트 저장소를 관리합니다.
* 그리드 노드 및 서비스를 모니터링하여 개체 가용성을 보장합니다.
* ILM(정보 수명 주기 관리) 규칙을 사용하여 시간이 지남에 따라 오브젝트 데이터의 배치를 관리합니다. 이러한 규칙은 수집된 개체의 데이터, 데이터가 손실되지 않도록 보호하는 방법, 오브젝트 데이터가 저장되는 위치 및 기간에 대해 적용됩니다.
* 시스템 내의 트랜잭션, 성능 및 운영을 모니터링합니다.




=== 정보 수명 주기 관리 정책

StorageGRID는 오브젝트의 복제본 보존 및 특정 성능 및 데이터 보호 요구사항에 따라 오브젝트를 저장할 수 있도록 2+1 및 4+2(특히 다른)와 같은 EC(삭제 코딩) 스키마를 사용하는 등의 유연한 데이터 관리 정책을 제공합니다. 시간에 따라 워크로드와 요구사항이 달라지날수록 ILM 정책도 시간에 따라 바뀌어야 합니다. ILM 정책을 수정하는 것은 핵심 기능이므로 StorageGRID 고객은 끊임없이 변화하는 환경에 빠르고 쉽게 적응할 수 있습니다. 를 확인하십시오 link:https://www.netapp.tv/player/26128/stream?assetType=movies["ILM 정책"^] 및 link:https://www.netapp.tv/player/25548/stream?assetType=movies["ILM 규칙"^] StorageGRID에서 설정.



=== 성능

StorageGRID는 VM, 베어 메탈 또는 특수 제작된 어플라이언스 등 스토리지 노드를 추가하여 성능을 확장합니다 link:https://www.netapp.com/pdf.html?item=/media/7931-ds-3613.pdf["SG5712, SG5760, SG6060 또는 SGF6024"^]. 이 테스트에서는 SGF6024 어플라이언스를 사용하는 최소 크기의 3노드 그리드로 Apache Kafka의 주요 성능 요구사항을 초과했습니다. 고객이 추가 브로커로 Kafka 클러스터를 확장함에 따라 스토리지 노드를 추가하여 성능과 용량을 확장할 수 있습니다.



=== 부하 분산 장치 및 엔드포인트 구성

StorageGRID의 관리 노드는 StorageGRID 시스템을 보고, 구성하고, 관리할 수 있는 그리드 관리자 UI(사용자 인터페이스) 및 REST API 엔드포인트와 시스템 작업을 추적할 수 있는 감사 로그를 제공합니다. Confluent Kafka 계층형 스토리지에 가용성이 높은 S3 엔드포인트를 제공하기 위해 관리 노드와 게이트웨이 노드에서 서비스로 실행되는 StorageGRID 로드 밸런서를 구현했습니다. 또한 로드 밸런서는 로컬 트래픽을 관리하고 GSLB(Global Server Load Balancing)에 연결하여 재해 복구를 지원합니다.

엔드포인트 구성을 더욱 개선하기 위해 StorageGRID는 관리 노드에 내장된 트래픽 분류 정책을 제공하고, 워크로드 트래픽을 모니터링하고, 워크로드에 다양한 QoS(서비스 품질) 제한을 적용할 수 있도록 지원합니다. 트래픽 분류 정책은 게이트웨이 노드 및 관리 노드에 대한 StorageGRID 부하 분산 서비스의 끝점에 적용됩니다. 이러한 정책은 트래픽 셰이핑 및 모니터링을 지원할 수 있습니다.



=== StorageGRID의 트래픽 분류

StorageGRID에는 QoS 기능이 내장되어 있습니다. 트래픽 분류 정책은 클라이언트 애플리케이션에서 들어오는 다양한 유형의 S3 트래픽을 모니터링하는 데 도움이 될 수 있습니다. 그런 다음 정책을 생성하여 적용하여 In/Out 대역폭, 읽기/쓰기 동시 요청 수 또는 읽기/쓰기 요청 속도에 따라 이 트래픽에 제한을 적용할 수 있습니다.



== 아파치 카프카

Apache Kafka는 Java 및 Scala로 작성된 스트림 처리를 사용하는 소프트웨어 버스의 프레임워크입니다. 이 제품은 실시간 데이터 피드 처리를 위한 높은 처리량의 짧은 대기 시간을 갖춘 통합 플랫폼을 제공하기 위해 마련되었습니다. Kafka는 데이터 내보내기 및 가져오기를 위해 Kafka Connect를 통해 외부 시스템에 연결할 수 있으며 Java 스트림 처리 라이브러리인 Kafka 스트림을 제공합니다. Kafka는 효율성을 위해 최적화된 바이너리 TCP 기반 프로토콜을 사용하며, 네트워크를 통한 왕복 작업의 오버헤드를 줄이기 위해 자연스럽게 메시지를 그룹화하는 "메시지 세트" 추상화에 의존합니다. 이렇게 하면 순차 디스크 작업, 더 큰 네트워크 패킷 및 연속 메모리 블록이 증가하므로 Kafka는 랜덤 메시지 쓰기의 폭주 스트림을 선형 쓰기로 전환할 수 있습니다. 다음 그림은 Apache Kafka의 기본 데이터 흐름을 보여 줍니다.

image::confluent-kafka-image5.png[통합된 Kafka 이미지5]

Kafka는 생산자라는 임의의 수의 프로세스에서 가져온 키 값 메시지를 저장합니다. 데이터는 여러 주제 내의 서로 다른 파티션으로 분할될 수 있습니다. 파티션 내에서 메시지는 해당 오프셋(파티션 내의 메시지 위치)에 의해 엄격하게 정렬되고 타임 스탬프와 함께 인덱싱되고 저장됩니다. 소비자라고 하는 다른 프로세스는 파티션에서 메시지를 읽을 수 있습니다. 스트림 처리를 위해 Kafka는 Kafka의 데이터를 사용하는 Java 애플리케이션을 작성하고 결과를 Kafka에 다시 쓸 수 있는 스트림 API를 제공합니다. Apache Kafka는 Apache Apex, Apache Flink, Apache Spark, Apache Storm, Apache nifi 등의 외부 스트림 처리 시스템과도 작동합니다.

Kafka는 하나 이상의 서버(브로커)로 구성된 클러스터에서 실행되며 모든 항목의 파티션이 클러스터 노드에 분산됩니다. 또한 파티션이 여러 브로커에 복제됩니다. 이 아키텍처를 통해 Kafka는 내결함성이 있는 방식으로 대규모 메시지 스트림을 전달할 수 있으며 JMS(Java Message Service), AMQP(Advanced Message Queuing Protocol) 등의 기존 메시징 시스템을 대체할 수 있습니다. Kafka는 0.11.0.0 릴리스 이후 트랜잭션 쓰기를 제공하여 스트림 API를 사용하여 정확히 한 번의 스트림 처리를 제공합니다.

Kafka는 일반과 컴팩션이라는 두 가지 유형의 주제를 지원합니다. 정규 주제는 보존 시간 또는 공간 바인딩으로 구성할 수 있습니다. 지정된 보존 시간보다 오래된 레코드가 있거나 파티션에 대해 바인딩된 공간이 초과된 경우 Kafka는 사용 가능한 저장소 공간을 확보하기 위해 이전 데이터를 삭제할 수 있습니다. 기본적으로 항목은 보존 기간이 7일로 구성되지만 데이터를 무기한 저장할 수도 있습니다. 압축된 항목의 경우 시간 또는 공간 범위에 따라 레코드가 만료되지 않습니다. 대신 Kafka는 나중에 받은 메시지를 동일한 키를 사용하는 이전 메시지의 업데이트로 취급하며 키당 최신 메시지를 삭제하지 않도록 보장합니다. 사용자는 특정 키에 대해 null 값을 갖는 소위 tombstone 메시지를 작성하여 메시지를 완전히 삭제할 수 있습니다.

Kafka에는 다음과 같은 5가지 주요 API가 있습니다.

* * Producer API. * 응용 프로그램에서 레코드 스트림을 게시할 수 있도록 허용합니다.
* * 소비자 API. * 응용 프로그램에서 항목 및 레코드 스트림 프로세스를 구독할 수 있도록 허용합니다.
* * Connector API. * 항목을 기존 응용 프로그램에 연결할 수 있는 재사용 가능한 프로듀서 및 소비자 API를 실행합니다.
* * Streams API. * 이 API는 입력 스트림을 출력으로 변환하고 결과를 생성합니다.
* * Admin API. * Kafka 주제, 브로커 및 기타 Kafka 객체를 관리하는 데 사용됩니다.


소비자 및 생산자 API는 Kafka 메시징 프로토콜을 기반으로 하며 Java의 Kafka 소비자 및 생산자 클라이언트에 대한 참조 구현을 제공합니다. 기본 메시징 프로토콜은 개발자가 프로그래밍 언어로 소비자 또는 생산자 클라이언트를 작성하는 데 사용할 수 있는 이진 프로토콜입니다. 이렇게 하면 JVM(Java Virtual Machine) 에코시스템에서 Kafka가 잠금 해제됩니다. 사용 가능한 비 Java 클라이언트 목록은 Apache Kafka wiki에서 유지 관리됩니다.



=== Apache Kafka 사용 사례

Apache Kafka는 메시징, 웹 사이트 활동 추적, 메트릭, 로그 집계, 스트림 처리, 이벤트 소싱 및 로깅 커밋

* Kafka는 향상된 처리량, 내장 파티셔닝, 복제 및 내결함성 기능을 제공하므로 대규모 메시지 처리 애플리케이션에 적합한 솔루션입니다.
* Kafka는 실시간 게시 구독 피드 집합으로 추적 파이프라인에서 사용자의 활동(페이지 보기, 검색)을 재구축할 수 있습니다.
* Kafka는 운영 모니터링 데이터에 자주 사용됩니다. 이를 위해서는 분산된 애플리케이션에서 통계를 집계하여 운영 데이터의 중앙 집중식 피드를 생성하는 작업이 필요합니다.
* 많은 사람들이 Kafka를 로그 집계 솔루션의 대안으로 사용합니다. 로그 집계는 일반적으로 서버에서 물리적 로그 파일을 수집하여 처리를 위해 중앙 위치(예: 파일 서버 또는 HDFS)에 배치합니다. Kafka는 파일 세부 정보를 추상화하고 로그 또는 이벤트 데이터를 메시지 스트림으로 추상화합니다. 따라서 대기 시간이 짧아지며 여러 데이터 소스 및 분산된 데이터 사용을 더욱 쉽게 지원할 수 있습니다.
* Kafka의 많은 사용자는 여러 스테이지로 구성된 처리 파이프라인에서 원시 입력 데이터가 Kafka 주제에서 소비된 후 추가 소비 또는 후속 처리를 위해 새로운 주제로 집계, 강화 또는 기타 방식으로 변환되는 데이터를 처리합니다. 예를 들어 뉴스 기사를 추천하기 위한 처리 파이프라인은 RSS 피드에서 기사 콘텐츠를 크롤링하여 "기사" 항목에 게시할 수 있습니다. 추가 처리에서는 이 콘텐츠를 정규화하거나 중복 제거하고 정리된 문서 콘텐츠를 새 주제에 게시하며 최종 처리 단계에서 사용자에게 이 콘텐츠를 추천하려고 할 수 있습니다. 이러한 처리 파이프라인은 개별 주제를 기반으로 실시간 데이터 플로우의 그래프를 작성합니다.
* 이벤트 수그리기는 상태 변경이 시간 순서 기록 시퀀스로 기록되는 응용 프로그램 디자인의 스타일입니다. Kafka는 매우 큰 저장 로그 데이터를 지원하므로 이 스타일로 구축된 애플리케이션에 대한 탁월한 백엔드로 활용할 수 있습니다.
* Kafka는 분산 시스템에 대한 일종의 외부 커밋 로그 역할을 할 수 있습니다. 이 로그는 노드 간 데이터를 복제하고 장애가 발생한 노드가 데이터를 복원할 수 있도록 재동기화 메커니즘 역할을 합니다. Kafka의 로그 컴팩션 기능은 이 활용 사례를 지원하는 데 도움이 됩니다.




== 유창하게

Confluent Platform은 Kafka를 완성하는 엔터프라이즈급 플랫폼으로, 애플리케이션 개발 및 연결 속도를 높이고, 스트림 처리를 통해 혁신을 지원하고, 규모에 따라 엔터프라이즈 운영을 간소화하고, 엄격한 아키텍처 요구 사항을 충족하도록 설계된 고급 기능을 제공합니다. Apache Kafka를 처음 개발한 Confluent는 Kafka 관리 또는 모니터링의 부담을 덜면서 엔터프라이즈급 기능을 통해 Kafka의 이점을 확장해 줍니다. 현재 Fortune 100대 기업 중 80% 이상이 데이터 스트리밍 기술을 사용하고 있으며 대부분 Confluent를 사용하고 있습니다.



=== 왜 Confluent인가?

Confluorent는 기록 데이터와 실시간 데이터를 단일 중앙 데이터 소스에 통합하여 완전히 새로운 범주의 최신 이벤트 기반 애플리케이션을 쉽게 구축하고, 범용 데이터 파이프라인을 구축하며, 완전한 확장성, 성능, 안정성으로 강력한 새 사용 사례를 활용할 수 있도록 지원합니다.



=== Contfluent는 어떤 용도로 사용됩니까?

Confluent Platform을 사용하면 데이터가 다른 시스템 간에 어떻게 전송 또는 통합되는지 등의 기본 메커니즘을 걱정하지 않고 데이터에서 비즈니스 가치를 창출하는 방법에 집중할 수 있습니다. 특히 Confluent Platform은 데이터 소스를 Kafka에 연결하고 스트리밍 애플리케이션을 구축하며 Kafka 인프라의 보안, 모니터링 및 관리를 간소화합니다. 현재 Confluent Platform은 금융 서비스, 옴니채널 소매, 자율 자동차, 사기 탐지 등 다양한 산업 전반의 다양한 사용 사례에 사용됩니다. 마이크로서비스, IoT

다음 그림에서는 Confluent Kafka 플랫폼 구성 요소를 보여 줍니다.

image::confluent-kafka-image6.png[통합된 Kafka 이미지6]



=== Confluent의 이벤트 스트리밍 기술 개요

Confluent Platform의 핵심은 입니다 https://kafka.apache.org/["아파치 카프카"^]가장 널리 사용되는 오픈 소스 분산 스트리밍 플랫폼입니다. Kafka의 주요 기능은 다음과 같습니다.

* 레코드 스트림을 게시하고 구독합니다.
* 내결함성이 있는 방식으로 레코드 스트림을 저장합니다.
* 레코드 스트림을 처리합니다.


즉시 사용할 수 있는 Confluorent Platform에는 스키마 레지스트리, REST 프록시, 총 100개 이상의 사전 구축된 Kafka 커넥터 및 ksqlDB도 포함되어 있습니다.



=== Confluent 플랫폼의 엔터프라이즈 기능 개요

* * Confluent Control Center. * Kafka 관리 및 모니터링을 위한 GUI 기반 시스템. Kafka Connect를 쉽게 관리하고 다른 시스템에 대한 연결을 생성, 편집 및 관리할 수 있습니다.
* Kubernetes를 위한 * Contfluent. * Kubernetes를 위한 Confluent는 Kubernetes 운영자입니다. Kubernetes 운영자는 특정 플랫폼 애플리케이션에 대한 고유한 기능과 요구 사항을 제공하여 Kubernetes의 오케스트레이션 기능을 확장합니다. Confluent Platform의 경우, Kubernetes에서 Kafka의 구축 프로세스를 크게 간소화하고 일반적인 인프라 라이프사이클 작업을 자동화할 수 있습니다.
* * Kafka * 커넥터에 대한 Confluent 커넥터 Kafka Connect API를 사용하여 Kafka를 데이터베이스, 키 값 저장소, 검색 인덱스 및 파일 시스템과 같은 다른 시스템에 연결합니다. Confluorent Hub에는 가장 널리 사용되는 데이터 소스 및 싱크에 대한 다운로드 가능한 커넥터가 있습니다. 여기에는 Confluorent Platform이 포함된 이러한 커넥터의 전체 테스트 및 지원 버전이 포함됩니다. 자세한 내용은 을 참조하십시오 https://docs.confluent.io/home/connect/userguide.html["여기"^].
* * 자체 밸런싱 클러스터 * 는 자동화된 로드 밸런싱, 장애 감지 및 자동 복구를 제공합니다. 필요에 따라 브로커를 추가하거나 해체할 수 있도록 지원하며 수동 튜닝이 필요하지 않습니다.
* * 연결 클러스터. * 직접 클러스터를 연결하고 링크 브리지를 통해 클러스터 간에 주제를 미러링합니다. 클러스터 링크를 사용하면 멀티 데이터 센터, 멀티 클러스터, 하이브리드 클라우드 구축을 간편하게 설정할 수 있습니다.
* * Confluorent auto data balancer. * 브로커 수, 파티션 크기, 파티션 수 및 클러스터 내의 리더 수에 대한 클러스터를 모니터링합니다. 균형 조정을 통해 트래픽을 재조정함으로써 운영 워크로드에 미치는 영향을 최소화하면서 클러스터 전체에서 짝수 워크로드를 생성할 수 있습니다.
* * Confluent Replicator. * 여러 데이터 센터에서 여러 Kafka 클러스터를 훨씬 쉽게 유지 관리할 수 있습니다.
* * 계층형 스토리지. * 즐겨 사용하는 클라우드 공급자를 사용하여 대량의 Kafka 데이터를 저장할 수 있는 옵션을 제공하므로 운영 부담과 비용이 줄어듭니다. 계층형 스토리지를 사용하면 비용 효율적인 오브젝트 스토리지에 데이터를 보관하고 더 많은 컴퓨팅 리소스가 필요할 때만 브로커를 확장할 수 있습니다.
* * Confluent JMS 클라이언트. * Confluent Platform에는 Kafka용 JMS 호환 클라이언트가 포함되어 있습니다. 이 Kafka 클라이언트는 Kafka 브로커를 백엔드로 사용하여 JMS 1.1 표준 API를 구현합니다. JMS를 사용하는 레거시 애플리케이션이 있고 기존 JMS 메시지 브로커를 Kafka로 교체하려는 경우 유용합니다.
* * Confluent MQTT proxy. * 중간에 MQTT 브로커가 없어도 MQTT 장치 및 게이트웨이에서 Kafka에 직접 데이터를 게시할 수 있는 방법을 제공합니다.
* * Confluent 보안 플러그인 * Confluent 보안 플러그인은 다양한 Confluent 플랫폼 도구 및 제품에 보안 기능을 추가하는 데 사용됩니다. 현재 Confluent REST 프록시에 사용할 수 있는 플러그인이 있어 수신 요청을 인증하고 인증된 보안 주체를 Kafka에 요청에 전파할 수 있습니다. 이렇게 하면 Confluent REST 프록시 클라이언트가 Kafka 브로커의 멀티테넌트 보안 기능을 활용할 수 있습니다.

