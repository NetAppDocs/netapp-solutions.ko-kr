---
sidebar: sidebar 
permalink: hyperv/hyperv-deploy.html 
keywords: hyperv, hyper-v, deploy, netapp, virtualization 
summary: 이 솔루션은 NetApp 스토리지에 Hyper-V를 구축하는 데 필요한 단계를 제공합니다 
---
= NetApp 스토리지에 Microsoft Hyper-V 구축
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ./../media/


[role="lead"]
Windows Server 플랫폼은 Hyper-V 역할을 사용하여 가상화 기술을 제공합니다. Hyper-V는 Windows Server와 함께 제공되는 여러 선택적 역할 중 하나입니다.



== 개요

Hyper-V 역할을 통해 Windows Server에 내장된 가상화 기술을 사용하여 가상화된 컴퓨팅 환경을 만들고 관리할 수 있습니다. Hyper-V 기술은 하드웨어를 가상화하여 하나의 물리적 컴퓨터에서 동시에 여러 운영 체제를 실행할 수 있는 환경을 제공합니다. Hyper-V를 사용하면 가상 머신과 해당 리소스를 생성하고 관리할 수 있습니다. 각 가상 머신은 자체 운영 체제를 실행할 수 있는 격리된 가상화 컴퓨터 시스템입니다. Hyper-V는 효율성 향상 및 비용 절감을 목표로 하는 다양한 비즈니스 목표를 지원하는 애플리케이션 및 워크로드를 가상화하는 인프라를 제공하며, 이는 VMware ® vSphere를 대체할 수 있는 완벽한 대안입니다. 특히 현재 시장 상황에서 여러 하이퍼바이저가 공존하기를 원하는 조직의 경우 더욱 그렇습니다.



== 대상

이 문서에서는 NetApp ONTAP 시스템을 사용한 Hyper-V 클러스터 구성의 아키텍처 및 구축 절차를 설명합니다. 이 문서는 세일즈 엔지니어, 현장 컨설턴트, 프로페셔널 서비스, IT 관리자, 파트너 엔지니어, Hyper-V를 운영 하이퍼바이저로 배포하거나 대체 하이퍼바이저로 배포하려는 고객을 대상으로 합니다.



== 있습니다

이 문서에 설명된 아키텍처에는 구체적으로 Microsoft ® Windows Server ® 2022 및 Hyper-V ® 가상화가 포함됩니다. NetApp은 가상화 소프트웨어와 인프라 관리 소프트웨어를 모든 구현에 적용하는 것이 좋습니다. 이 FlexPod Express 구성은 안정적인 엔터프라이즈급 인프라를 구축할 수 있도록 각 구성요소의 모범 사례를 사용합니다.



== 사용 사례 요약입니다

이 문서에서는 NetApp All-Flash FAS 및 ASA 어레이 모델을 사용하여 Microsoft Windows Server 2022에서 워크로드로 최적으로 수행하도록 Hyper-V 클러스터를 설정하기 위한 구축 절차와 모범 사례에 대해 설명합니다. 서버 운영 체제/하이퍼바이저는 Microsoft Windows Server 2022입니다. 이 지침에서는 SAN(Storage Area Network) 및 NAS(Network-Attached Storage) 프로토콜을 통해 데이터를 제공하는 NetApp 스토리지 시스템에 대해 다룹니다.



== 구현 절차

이 항목에서는 ONTAP 스토리지 시스템을 활용하여 2노드 페일오버 클러스터 및 클러스터 Hyper-V 가상 머신을 구성 및 구축하는 단계를 설명합니다.



=== 구현 절차를 위한 사전 요구 사항

* 모든 하드웨어는 실행 중인 Windows Server 버전에 대해 인증을 받아야 하며 전체 장애 조치 클러스터 솔루션은 구성 유효성 검사 마법사에서 모든 테스트를 통과해야 합니다
* 도메인 컨트롤러에 연결된 Hyper-V 노드(권장) 및 상호 간의 적절한 연결
* 모든 Hyper-V 노드는 동일하게 구성되어야 합니다.
* 관리, iSCSI, SMB, 실시간 마이그레이션을 위해 분리된 트래픽을 위해 각 Hyper-V 서버에 구성된 네트워크 어댑터 및 지정된 가상 스위치
* 페일오버 클러스터 기능은 각 Hyper-V 서버에서 활성화되어 있습니다.
* SMB 공유 또는 CSV는 Hyper-V 클러스터링용 VM 및 해당 디스크를 저장하기 위한 공유 스토리지로 사용됩니다.
* 서로 다른 클러스터 간에 스토리지를 공유해서는 안 됩니다. 클러스터당 하나 이상의 CSV/CIFS 공유를 계획합니다.
* SMB 공유를 공유 스토리지로 사용하는 경우 클러스터에 있는 모든 Hyper-V 노드의 컴퓨터 계정에 대한 액세스 권한을 부여하도록 SMB 공유에 대한 권한을 구성해야 합니다.


자세한 내용은 다음을 참조하십시오.

* link:https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/system-requirements-for-hyper-v-on-windows#how-to-check-for-hyper-v-requirements["Windows Server의 Hyper-V에 대한 시스템 요구 사항"]
* link:https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/jj134244(v=ws.11)#step-1-prepare-to-validate-hardware-for-a-failover-cluster["장애 조치 클러스터의 하드웨어 유효성 검사"]
* link:https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/jj863389(v=ws.11)["Hyper-V 클러스터를 구축합니다"]


.Windows 기능 설치
[%collapsible]
====
다음 단계에서는 필요한 Windows Server 2022의 기능을 설치하는 방법을 설명합니다.

* 모든 호스트 *

. 지정된 모든 노드에서 필요한 업데이트와 장치 드라이버를 사용하여 Windows OS 2022를 준비합니다.
. 설치 중에 입력한 관리자 암호를 사용하여 각 Hyper-V 노드에 로그인합니다.
. 작업 표시줄에서 PowerShell 아이콘을 마우스 오른쪽 버튼으로 클릭하고 을 선택하여 PowerShell 프롬프트를 시작합니다 `Run as Administrator`.
. Hyper-V, MPIO 및 클러스터링 기능을 추가합니다.
+
[source, cli]
----
Add-WindowsFeature Hyper-V, Failover-Clustering, Multipath-IO `-IncludeManagementTools –Restart
----


====
.네트워크 구성
[%collapsible]
====
내결함성 구축을 위해서는 올바른 네트워크 계획이 중요합니다. 각 트래픽 유형에 대해 서로 다른 물리적 네트워크 어댑터를 설정하는 것이 장애 조치 클러스터의 표준 제안이었습니다. 가상 네트워크 어댑터 추가 기능, 내장된 팀 구성(세트) 전환 기능 및 도입된 Hyper-V QoS와 같은 기능을 통해 적은 수의 물리적 어댑터에서 네트워크 트래픽을 압축할 수 있습니다. 서비스 품질, 이중화 및 트래픽 격리를 고려하여 네트워크 구성을 설계하십시오. VLAN과 같은 네트워크 격리 기술을 트래픽 격리 기술과 함께 구성하면 트래픽 및 서비스 품질에 대한 중복성이 확보되어 스토리지 트래픽 성능을 개선하고 일관성을 높일 수 있습니다.

여러 논리적 및/또는 물리적 네트워크를 사용하여 특정 워크로드를 분리하고 격리하는 것이 좋습니다. 일반적으로 세그먼트로 분할되는 일반적인 네트워크 트래픽의 예는 다음과 같습니다.

* iSCSI 스토리지 네트워크.
* CSV(Cluster Shared Volume) 또는 Heartbeat 네트워크.
* 실시간 마이그레이션
* VM 네트워크
* 관리 네트워크



NOTE: 전용 NIC와 함께 iSCSI를 사용하는 경우 팀 구성 솔루션을 사용하지 않는 것이 좋으며 MPIO/DSM을 사용해야 합니다.


NOTE: Hyper-V 네트워킹 모범 사례도 Hyper-V 환경에서 SMB 3.0 스토리지 네트워크용 NIC 팀 구성을 사용하지 않는 것이 좋습니다.

자세한 내용은 을 참조하십시오 link:https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/plan/plan-hyper-v-networking-in-windows-server["Windows Server에서의 Hyper-V 네트워킹 계획"]

====
.Hyper-V용 스토리지 설계 결정
[%collapsible]
====
Hyper-V는 NAS(SMB3.0) 및 블록 스토리지(iSCSI/FC)를 가상 머신의 백업 스토리지로 지원합니다. NetApp는 iSCSI/FC 및 SMB3을 사용하여 VM용 네이티브 스토리지로 사용할 수 있는 SMB3.0, iSCSI 및 FC 프로토콜을 지원합니다. 또한 고객은 스토리지에 대한 직접 액세스가 필요한 워크로드의 경우 SMB3 및 iSCSI를 게스트 연결 스토리지 옵션으로 사용할 수 있습니다. ONTAP는 혼합 프로토콜 액세스가 필요한 워크로드에 유니파이드 스토리지(All-Flash 어레이)와 SAN 전용 구성을 위한 SAN 최적화 스토리지(All SAN 어레이)가 포함된 유연한 옵션을 제공합니다.

SMB3을 iSCSI/FC와 비교하면 기존 인프라스트럭처에 따라 SMB3/iSCSI를 사용하여 기존 네트워크 인프라스트럭처를 사용할 수 있습니다. 기존 FC 인프라가 있는 고객의 경우 해당 인프라를 활용하여 스토리지를 FC 기반 클러스터 공유 볼륨으로 제공할 수 있습니다.

* 참고: * ONTAP 소프트웨어를 실행하는 NetApp 스토리지 컨트롤러는 Hyper-V 환경에서 다음과 같은 워크로드를 지원할 수 있습니다.

* 지속적으로 사용 가능한 SMB 3.0 공유에서 호스팅되는 VM입니다
* iSCSI 또는 FC에서 실행 중인 CSV(클러스터 공유 볼륨) LUN에 호스팅된 VM
* 게스트 내 스토리지 및 게스트 가상 컴퓨터로 디스크를 전달합니다



NOTE: 씬 프로비저닝, 중복제거, 압축, 데이터 컴팩션, 유연한 클론 복제 등의 핵심 ONTAP 기능 스냅샷 및 복제는 플랫폼 또는 운영 체제에 관계없이 백그라운드에서 원활하게 작동하며 Hyper-V 워크로드에 상당한 가치를 제공합니다. 이러한 기능의 기본 설정은 Windows Server 및 Hyper-V에 최적입니다


NOTE: MPIO는 VM에 여러 경로를 사용할 수 있고 다중 경로 I/O 기능이 설치 및 구성된 경우 게스트 내 이니시에이터를 사용하여 게스트 VM에서 지원됩니다.


NOTE: ONTAP는 NFS, SMB, FC, FCoE, iSCSI, iSCSI 등의 모든 주요 업계 표준 클라이언트 프로토콜을 NVMe/FC 및 S3 그러나 NVMe/FC 및 NVMe/TCP는 Microsoft에서 지원되지 않습니다.

====
.NetApp Windows iSCSI Host Utilities를 설치합니다
[%collapsible]
====
다음 섹션에서는 NetApp Windows iSCSI Host Utilities 자동 설치를 수행하는 방법을 설명합니다. 설치에 대한 자세한 내용은 를 참조하십시오 link:https://docs.netapp.com/us-en/ontap-sanhost/hu_wuhu_72.html["Windows Unified Host Utilities 7.2(또는 지원되는 최신 버전)를 설치합니다."]

* 모든 호스트 *

. 다운로드 link:https://mysupport.netapp.com/site/products/all/details/hostutilities/downloads-tab/download/61343/7.2["Windows iSCSI Host Utilities.(Windows iSCSI 호스트 유틸리티"]
. 다운로드한 파일의 차단을 해제합니다.
+
[source, cli]
----
Unblock-file ~\Downloads\netapp_windows_host_utilities_7.2_x64.msi
----
. Host Utilities를 설치합니다.
+
[source, cli]
----
~\Downloads\netapp_windows_host_utilities_7.2_x64.msi /qn "MULTIPATHING=1"
----



NOTE: 이 프로세스 중에 시스템이 재부팅됩니다.

====
.Windows 호스트 iSCSI 이니시에이터를 구성하는 중입니다
[%collapsible]
====
다음 단계에서는 내장된 Microsoft iSCSI 이니시에이터를 구성하는 방법을 설명합니다.

* 모든 호스트 *

. 작업 표시줄에서 PowerShell 아이콘을 마우스 오른쪽 버튼으로 클릭하고 "관리자 권한으로 실행"을 선택하여 PowerShell 프롬프트를 시작합니다.
. 자동으로 시작되도록 iSCSI 서비스를 구성합니다.
+
[source, cli]
----
Set-Service -Name MSiSCSI -StartupType Automatic
----
. iSCSI 서비스를 시작합니다.
+
[source, cli]
----
Start-Service -Name MSiSCSI
----
. 모든 iSCSI 장치를 확보하도록 MPIO를 구성합니다.
+
[source, cli]
----
Enable-MSDSMAutomaticClaim -BusType iSCSI
----
. 새로 확보되는 모든 장치의 기본 로드 밸런싱 정책을 라운드 로빈으로 설정합니다.
+
[source, cli]
----
Set-MSDSMGlobalDefaultLoadBalancePolicy -Policy RR 
----
. 각 컨트롤러의 iSCSI 타깃을 구성합니다.
+
[source, cli]
----
New-IscsiTargetPortal -TargetPortalAddress <<iscsia_lif01_ip>> -InitiatorPortalAddress <iscsia_ipaddress>

New-IscsiTargetPortal -TargetPortalAddress <<iscsib_lif01_ip>> -InitiatorPortalAddress <iscsib_ipaddress

New-IscsiTargetPortal -TargetPortalAddress <<iscsia_lif02_ip>> -InitiatorPortalAddress <iscsia_ipaddress>

New-IscsiTargetPortal -TargetPortalAddress <<iscsib_lif02_ip>> -InitiatorPortalAddress <iscsib_ipaddress>
----
. 각 iSCSI 네트워크의 세션을 각 타깃에 연결합니다.
+
[source, cli]
----
Get-IscsiTarget | Connect-IscsiTarget -IsPersistent $true -IsMultipathEnabled $true -InitiatorPo rtalAddress <iscsia_ipaddress>

Get-IscsiTarget | Connect-IscsiTarget -IsPersistent $true -IsMultipathEnabled $true -InitiatorPo rtalAddress <iscsib_ipaddress>
----



NOTE: 성능 향상 및 대역폭 활용을 위해 여러 세션(최소 5-8개)을 추가합니다.

====
.클러스터 생성
[%collapsible]
====
* 서버 1대만 해당 *

. PowerShell 아이콘을 마우스 오른쪽 버튼으로 클릭하고 을 선택하여 관리 권한이 있는 PowerShell 프롬프트를 시작합니다 `Run as Administrator``.
. 새 클러스터를 생성합니다.
+
[source, cli]
----
New-Cluster -Name <cluster_name> -Node <hostnames> -NoStorage -StaticAddress <cluster_ip_address>
----
+
image:hyperv-deploy-image01.png["클러스터 관리 인터페이스를 보여 주는 이미지"]

. 실시간 마이그레이션에 적합한 클러스터 네트워크를 선택합니다.
. CSV 네트워크를 지정합니다.
+
[source, cli]
----
(Get-ClusterNetwork -Name Cluster).Metric = 900
----
. 쿼럼 디스크를 사용하도록 클러스터를 변경합니다.
+
.. PowerShell 아이콘을 마우스 오른쪽 버튼으로 클릭하고 '관리자 권한으로 실행'을 선택하여 관리 권한이 있는 PowerShell 프롬프트를 시작합니다.
+
[source, cli]
----
start-ClusterGroup "Available Storage"| Move-ClusterGroup -Node $env:COMPUTERNAME
----
.. Failover Cluster Manager에서 를 선택합니다 `Configure Cluster Quorum Settings`.
+
image:hyperv-deploy-image02.png["클러스터 쿼럼 구성 설정 이미지"]

.. 시작 페이지에서 다음 을 클릭합니다.
.. quorum witness를 선택하고 Next를 클릭합니다.
.. Configure a disk witness"를 선택하고 Next를 클릭합니다.
.. 사용 가능한 스토리지에서 Disk W:를 선택하고 Next를 클릭합니다.
.. 확인 페이지가 사라질 때까지 Next를 클릭하다가 요약 페이지에서 Finish를 클릭합니다.
+
쿼럼과 증인에 대한 자세한 내용은 을 참조하십시오 link:https://learn.microsoft.com/en-us/windows-server/failover-clustering/manage-cluster-quorum#general-recommendations-for-quorum-configuration["쿼럼 구성 및 관리"]



. Failover Cluster Manager에서 Cluster Validation Wizard를 실행하여 배포를 검증합니다.
. CSV LUN을 생성하여 가상 머신 데이터를 저장하고 Failover Cluster Manager 내의 역할을 통해 고가용성 가상 머신을 생성합니다.


====


== 고려 사항, 기능 및 통합



=== 고려해야 할 요소

이 단계는 Hyper-V 환경에서 애플리케이션, 서비스 및 워크로드가 효과적으로 운영되도록 하는 데 중요합니다. 호환성 검사에는 운영 체제 버전, Windows 서버 버전, 응용 프로그램 종속성, 데이터베이스 시스템 및 기존 환경에 존재하는 특정 구성 또는 사용자 지정이 포함되어야 합니다.

.스토리지 크기를 적절하게 조정합니다
[%collapsible]
====
워크로드를 구축하거나 기존 하이퍼바이저에서 마이그레이션하기 전에 필요한 성능을 충족할 수 있도록 워크로드 크기를 조정해야 합니다. CPU(사용/프로비저닝), 메모리(사용/프로비저닝), 스토리지(프로비저닝/활용), 네트워크 처리량 및 지연 시간과 읽기/쓰기 IOPS, 처리량 및 블록 크기의 집계에 대한 통계를 수집하는 개별 VM에 대한 성능 데이터를 수집하여 이를 쉽게 수행할 수 있습니다. 이러한 매개 변수는 성공적으로 구축되고 스토리지 시스템 및 워크로드 호스트의 크기를 올바르게 지정하는 데 필요합니다.


NOTE: Hyper-V 및 관련 워크로드에 대한 스토리지 사이징 시 IOPS 및 용량 계획


NOTE: I/O가 많은 VM 또는 많은 리소스와 용량이 필요한 VM의 경우 OS와 데이터 디스크를 분리합니다. 운영 체제 및 애플리케이션 바이너리는 자주 변경되지 않으며 볼륨 충돌 정합성이 보장됩니다.


NOTE: VHD를 사용하는 것보다 고성능 데이터 디스크에 게스트 연결 스토리지(게스트 내)를 사용합니다. 이렇게 하면 복제 프로세스도 쉬워집니다.

====
.가상 시스템 성능 향상
[%collapsible]
====
단일 가상 SCSI 컨트롤러에 여러 디스크를 연결하는 동시에 최적의 성능을 위해 적절한 RAM 및 vCPU 양을 선택합니다. 고정 VHDX는 여전히 구축 시 가상 디스크의 기본 선택으로 권장되며 VHDX 가상 디스크를 사용하는 데 제한이 없습니다.


NOTE: 사용하지 않을 Windows Server에 불필요한 역할을 설치하지 마십시오.


NOTE: SCSI 컨트롤러에서 VM을 로드할 수 있는 가상 시스템의 세대로 Gen2를 선택하고 부팅 레벨에 대한 VMBus 및 VSP/VSC 아키텍처를 기반으로 하므로 전체 VM 성능이 크게 향상됩니다.


NOTE: 체크포인트가 VM 성능에 부정적인 영향을 주기 때문에 체크포인트를 자주 사용하지 마십시오.

====
.SMB3.0 설계 및 고려 사항
[%collapsible]
====
SMB 3.0 파일 공유를 Hyper-V용 공유 스토리지로 사용할 수 있습니다 ONTAP은 Hyper-V에 대해 SMB 공유를 통해 무중단 운영을 지원합니다 Hyper-V는 SMB 파일 공유를 사용하여 구성, 스냅샷 및 VHD(가상 하드 디스크) 파일과 같은 가상 머신 파일을 저장할 수 있습니다. Hyper-V를 위해 SMB3.0 기반 공유를 위한 전용 ONTAP CIFS SVM을 사용합니다 가상 머신 파일을 저장하는 데 사용되는 볼륨은 NTFS 보안 스타일 볼륨으로 생성해야 합니다. 10GB 네트워크가 있는 경우 Hyper-V 호스트와 NetApp 어레이 간의 연결을 사용하는 것이 좋습니다. 1GB 네트워크 연결의 경우 NetApp에서는 여러 개의 1GB 포트로 구성된 인터페이스 그룹을 생성할 것을 권장합니다. SMB 다중 채널을 지원하는 각 NIC를 전용 IP 서브넷에 연결하여 각 서브넷이 클라이언트와 서버 간의 단일 경로를 제공하도록 합니다.

키 포인트

* ONTAP SVM에서 SMB 멀티 채널을 지원합니다
* ONTAP CIFS SVM은 클러스터의 각 노드에 하나 이상의 데이터 LIF가 있어야 합니다.
* 사용된 공유는 연속적으로 사용 가능한 속성 집합으로 구성해야 합니다.
* ONTAP One은 현재 모든 AFF(A-Series 및 C-Series), All-SAN 어레이(ASA) 및 FAS 시스템에 포함되어 있습니다. 따라서 별도의 라이센스가 필요하지 않습니다.
* 공유 VHDX의 경우 게스트 연결 iSCSI LUN을 사용합니다



NOTE: ODX는 프로토콜 전반에서 지원되며 작동합니다. 파일 공유와 iSCSI 또는 FCP 연결 LUN 간에 데이터를 복사하는 경우에도 ODX를 활용합니다.


NOTE: 그에 따라 클러스터의 노드에 대한 시간 설정을 설정해야 합니다. NetApp CIFS 서버가 Windows AD(Active Directory) 도메인에 참여해야 하는 경우 NTP(네트워크 시간 프로토콜)를 사용해야 합니다.


NOTE: CIFS 서버를 통해 큰 MTU 값을 활성화해야 합니다. 패킷 크기가 작으면 성능이 저하될 수 있습니다.

====
.SMB 볼륨을 프로비저닝하는 중입니다
[%collapsible]
====
. 필요한 CIFS 서버 옵션이 스토리지 가상 머신(SVM)에 활성화되어 있는지 확인
. 다음 옵션을 true로 설정해야 합니다. SMB2 사용 SMB3 사용 복사 오프로드 사용 섀도우복제 사용 가능 은 다중 채널 사용 가능 은 large-mtu 사용 입니다
+
image:hyperv-deploy-image03.png["SMB 열 설정 이미지"]

. 스토리지 가상 머신(SVM)에서 NTFS 데이터 볼륨을 생성한 다음 Hyper-V에서 사용할 수 있도록 지속적으로 사용 가능한 공유를 구성합니다
+
image:hyperv-deploy-image04.png["NTFS 데이터 볼륨 설정 이미지"]

+

NOTE: 구성에 사용된 볼륨을 NTFS 보안 스타일 볼륨으로 생성하지 않는 한 SMB를 통한 Hyper-V의 무중단 작업은 올바르게 작동하지 않습니다.

. 지속적인 사용 가능 상태를 유지하고 모든 권한을 가진 Hyper-V 노드를 포함하도록 공유에서 NTFS 권한을 구성합니다.
+
image:hyperv-deploy-image05.png["NTFS 권한 설정 이미지"]



자세한 모범 사례 지침은 을 참조하십시오 link:https://docs.netapp.com/us-en/ontap-apps-dbs/microsoft/win_overview.html["Hyper-V에 대한 배포 지침 및 모범 사례"].

자세한 내용은 을 참조하십시오 link:https://docs.netapp.com/us-en/ontap/smb-hyper-v-sql/server-volume-requirements-hyper-v-concept.html["SMB를 통한 Hyper-V의 SMB 서버 및 볼륨 요구 사항
"].

====
.블록 프로토콜 설계 및 고려 사항
[%collapsible]
====
키 포인트

* 호스트에서 다중 경로(MPIO)를 사용하여 다중 경로를 관리합니다. 데이터 이동성 작업을 촉진하거나 추가 I/O 리소스를 활용하기 위해 필요한 경로를 하나 호스트 OS가 지원할 수 있는 최대 경로 수를 초과하지 마십시오.
* LUN에 액세스하는 호스트에 Host Utilities 키트를 설치합니다.
* 최소 8개의 볼륨을 생성합니다.



NOTE: 볼륨당 하나의 LUN을 사용하므로 LUN 대 CSV 비율에 대해 1:1 매핑이 가능합니다.

* SVM은 iSCSI 또는 파이버 채널을 사용하여 데이터를 처리하려는 모든 스토리지 컨트롤러에 이더넷 네트워크당 하나의 LIF가 있거나 파이버 채널 패브릭당 하나의 LIF가 있어야 합니다.
* FCP 또는 iSCSI로 데이터를 제공하는 SVM에는 SVM 관리 인터페이스가 필요합니다.


====
.iSCSI 볼륨 프로비저닝
[%collapsible]
====
iSCSI 볼륨을 프로비저닝하려면 다음과 같은 사전 요구 사항이 충족되어야 합니다.

* 스토리지 가상 머신(SVM)에는 iSCSI 프로토콜이 활성화되고 적절한 논리 인터페이스(LIF)가 생성되어야 합니다.
* 지정된 애그리게이트에는 LUN을 포함할 수 있는 충분한 여유 공간이 있어야 합니다.



NOTE: 기본적으로 ONTAP에서는 SLM(선택적 LUN 맵)을 사용하여 LUN 및 고가용성(HA) 파트너가 있는 노드의 경로를 통해서만 LUN에 액세스할 수 있도록 합니다.

* LUN이 클러스터의 다른 노드로 이동되는 경우를 대비하여 모든 노드에서 LUN 이동성을 위해 iSCSI LIF를 구성합니다.


* 단계 *

. System Manager를 사용하여 LUN 창으로 이동합니다(ONTAP CLI를 동일한 작업에 사용할 수 있음).
. 생성 을 클릭합니다.
. LUN을 생성할 지정된 SVM을 찾아 선택하고 LUN 생성 마법사를 표시합니다.
. General Properties 페이지에서 Hyper-V 가상 머신에 대한 VHD(가상 하드 디스크)를 포함하는 LUN의 경우 Hyper-V를 선택합니다.
+
image:hyperv-deploy-image06.png["Hyper-V LUN 생성을 위한 일반 속성 페이지 이미지"]

. LUN 컨테이너 페이지에서 기존 FlexVol 볼륨을 선택합니다. 그렇지 않으면 새 볼륨이 생성됩니다.
. <<추가 옵션>>이니시에이터 매핑 페이지에서 이니시에이터 그룹 추가를 클릭하고 일반 탭에 필요한 정보를 입력한 다음, 이니시에이터 탭에 호스트의 iSCSI 이니시에이터 노드 이름을 입력합니다.
. 세부 정보를 확인한 다음 마침 을 클릭하여 마법사를 완료합니다.


LUN이 생성되면 Failover Cluster Manager로 이동합니다. CSV에 디스크를 추가하려면 해당 디스크를 클러스터의 사용 가능한 스토리지 그룹(아직 추가되지 않은 경우)에 추가한 다음 클러스터의 CSV에 디스크를 추가해야 합니다.


NOTE: CSV 기능은 페일오버 클러스터링에서 기본적으로 설정됩니다.

* 사용 가능한 스토리지에 디스크 추가: *

. Failover Cluster Manager의 콘솔 트리에서 클러스터 이름을 확장한 다음 Storage를 확장합니다.
. Disks를 마우스 오른쪽 단추로 클릭한 다음 Add Disk를 선택합니다. 페일오버 클러스터에서 사용할 수 있도록 추가할 수 있는 디스크를 보여 주는 목록이 나타납니다.
. 추가할 디스크를 선택한 다음 확인 을 선택합니다.
. 이제 디스크가 사용 가능한 스토리지 그룹에 할당됩니다.
. 완료되면 사용 가능한 스토리지에 할당된 디스크를 선택하고 선택 항목을 마우스 오른쪽 버튼으로 클릭한 다음 Add to Cluster Shared Volumes 를 선택합니다.
+
image:hyperv-deploy-image07.png["Add to Cluster Shared Volumes 인터페이스 이미지"]

. 이제 디스크가 클러스터의 클러스터 공유 볼륨 그룹에 할당됩니다. 디스크는 %SystemDrive% ClusterStorage 폴더 아래에 번호가 매겨진 볼륨(마운트 지점)으로 각 클러스터 노드에 표시됩니다. 볼륨이 CSVFS 파일 시스템에 나타납니다.


자세한 내용은 을 참조하십시오 link:https://learn.microsoft.com/en-us/windows-server/failover-clustering/failover-cluster-csvs#add-a-disk-to-csv-on-a-failover-cluster["장애 조치 클러스터에서 클러스터 공유 볼륨을 사용합니다"].

* 고가용성 가상 머신 생성: *

고가용성 가상 머신을 생성하려면 다음 단계를 수행하십시오.

. Failover Cluster Manager에서 원하는 클러스터를 선택하거나 지정합니다. 클러스터 아래의 콘솔 트리가 확장되었는지 확인합니다.
. 역할을 클릭합니다.
. 작업 창에서 가상 시스템 을 클릭한 다음 새 가상 시스템 을 클릭합니다. 새 가상 머신 마법사가 나타납니다. 다음 을 클릭합니다.
. 이름 및 위치 지정 페이지에서 nimdemo 와 같은 가상 머신의 이름을 지정합니다. Store the virtual machine in a different location 을 클릭한 다음 전체 경로를 입력하거나 Browse 를 클릭하고 공유 스토리지로 이동합니다.
. 메모리를 할당하고 네트워크 어댑터를 물리적 네트워크 어댑터와 연결된 가상 스위치에 구성합니다.
. 가상 하드 디스크 연결 페이지에서 가상 하드 디스크 만들기를 클릭합니다.
. 설치 옵션 페이지에서 부팅 CD/DVD-ROM에서 운영 체제 설치 를 클릭합니다. 미디어 에서 미디어 위치를 지정한 다음 마침 을 클릭합니다.
. 가상 머신이 생성됩니다. 그러면 Failover Cluster Manager의 고가용성 마법사가 고가용성을 위해 가상 머신을 자동으로 구성합니다.


====
.ODX 기능을 사용하여 가상 디스크의 신속한 프로비저닝
[%collapsible]
====
ONTAP의 ODX 기능을 사용하면 ONTAP 스토리지 시스템에서 호스팅하는 마스터 VHDX 파일을 복사하기만 하면 마스터 VHDX를 복제할 수 있습니다. ODX 지원 복제는 네트워크 연결에 데이터를 보관하지 않기 때문에 복사 프로세스가 NetApp 스토리지 측에서 수행되므로, 6~8배 더 빠릅니다. 빠른 프로비저닝을 위한 일반적인 고려 사항으로는 파일 공유에 저장된 마스터 sysprepped 이미지와 Hyper-V 호스트 시스템에서 시작하는 일반 복제 프로세스가 있습니다.


NOTE: ONTAP은 SMB 및 SAN 프로토콜을 모두 지원하는 ODX를 지원합니다.


NOTE: Hyper-V를 사용한 ODX 복사 오프로드 패스스루의 활용 사례를 활용하려면 게스트 운영 체제가 ODX를 지원해야 하며, 게스트 운영 체제의 디스크는 ODX를 지원하는 스토리지(SMB 또는 SAN)를 통해 지원되는 SCSI 디스크여야 합니다. 게스트 운영 체제의 IDE 디스크는 ODX 패스스스루 를 지원하지 않습니다.

====
.성능 최적화
[%collapsible]
====
CSV당 권장되는 VM 수는 주관적이지만 여러 가지 요인에 따라 각 CSV 또는 SMB 볼륨에 배치할 수 있는 최적의 VM 수가 결정됩니다. 대부분의 관리자가 용량만 고려하지만, VHDX에 전송되는 동시 I/O 양은 전반적인 성능을 위한 가장 중요한 요소 중 하나입니다. 성능을 제어하는 가장 쉬운 방법은 각 CSV 또는 공유에 배치된 가상 시스템의 수를 조정하는 것입니다. 동시 가상 머신 입출력 패턴이 너무 많은 트래픽을 CSV 또는 공유로 전송하는 경우 디스크 큐가 채워지고 지연 시간이 늘어납니다.

====
.SMB 볼륨 및 CSV 사이징
[%collapsible]
====
병목 현상을 방지하기 위해 솔루션의 크기를 적절하게 지정하고 Hyper-V VM 스토리지 용도로 볼륨을 생성할 경우 필요 이상의 볼륨을 생성하는 것이 가장 좋습니다. 볼륨 크기를 적절하게 조정하면 CSV에 너무 많은 가상 시스템이 실수로 배치되는 것을 방지하고 리소스 경합 가능성을 줄일 수 있습니다. 각 클러스터 공유 볼륨(CSV)은 하나의 VM 또는 여러 개의 VM을 지원합니다. CSV에 배치할 VM의 수는 워크로드 및 비즈니스 기본 설정과 스냅샷 및 복제와 같은 ONTAP 스토리지 기능을 사용하는 방법에 따라 결정됩니다. CSV에 여러 VM을 배치하는 것은 대부분의 배포 시나리오에서 좋은 시작점입니다. 성능 및 데이터 보호 요구사항을 충족할 수 있도록 특정 사용 사례에 맞게 이 접근 방식을 조정합니다.

볼륨과 VHDX 크기는 쉽게 늘릴 수 있으므로 VM에 추가 용량이 필요한 경우 필요한 것보다 더 큰 CSV를 사이징할 필요가 없습니다. diskpart는 CSV 크기를 확장하는 데 사용할 수 있습니다. 또는 보다 쉬운 방법은 새 CSV를 만들고 필요한 VM을 새 CSV로 마이그레이션하는 것입니다. 최적의 성능을 위해서는 중간 측정으로 크기를 늘리는 것이 아니라 CSV의 수를 늘리는 것이 가장 좋습니다.

====
.마이그레이션
[%collapsible]
====
현재 시장 상황에서 가장 일반적인 사용 사례 중 하나는 마이그레이션입니다. 고객은 VMM Fabric 또는 다른 타사 마이그레이션 도구를 사용하여 VM을 마이그레이션할 수 있습니다. 이러한 툴은 호스트 레벨 복제본을 사용하여 소스 플랫폼에서 대상 플랫폼으로 데이터를 이동합니다. 이 툴은 마이그레이션 범위에 있는 가상 머신 수에 따라 시간이 오래 걸릴 수 있습니다.

이러한 시나리오에서 ONTAP을 사용하면 호스트 기반 마이그레이션 프로세스보다 더 빠르게 마이그레이션할 수 있습니다. 또한 ONTAP를 사용하면 한 하이퍼바이저에서 다른 하이퍼바이저로 VM을 신속하게 마이그레이션할 수 있습니다(이 경우에는 ESXi에서 Hyper-V로). NetApp 스토리지에서 어떤 크기의 VMDK도 몇 초 이내에 VHDX로 변환할 수 있습니다. 이것이 바로 NetApp FlexClone ® 기술을 활용하여 VM 하드 디스크를 빠르게 변환하는 PowerShell 방식입니다. 타겟 및 대상 VM의 생성 및 구성도 처리합니다.

이 프로세스는 가동 중지 시간을 최소화하고 비즈니스 생산성을 향상시키는 데 도움이 됩니다. 또한 단일 공급업체에 대한 라이센싱 비용, 종속 및 약정을 줄임으로써 다양한 옵션과 유연성을 제공합니다. 이는 VM 라이센스 비용을 최적화하고 IT 예산을 늘리려는 조직에도 유용합니다.

FlexClone 및 PowerShell을 사용한 마이그레이션에 대한 자세한 내용은 을 참조하십시오 link:#appendix["부록 A"].

====


=== 데이터 보호

.NetApp 스토리지 스냅샷을 사용하여 복구합니다
[%collapsible]
====
VM을 백업하고 신속하게 복구하거나 클론 생성하는 것은 ONTAP 볼륨의 뛰어난 강점 중 하나입니다. 스냅샷 복사본을 사용하여 성능에 영향을 주지 않고 VM 또는 전체 CSV 볼륨의 빠른 FlexClone 복사본을 만들 수 있습니다. 따라서 운영 데이터 볼륨을 클론 복제하고 QA, 스테이징 및 개발 환경에 마운트할 때 데이터 손상의 위험 없이 운영 데이터를 사용할 수 있습니다. FlexClone 볼륨은 데이터를 복사하는 데 필요한 공간의 양이 두 배로 늘어나지 않고도 운영 데이터의 테스트 복사본을 만드는 데 유용합니다.

Hyper-V 노드는 각 디스크에 고유한 ID를 할당하고 각 파티션(MBR 또는 GPT)이 있는 볼륨의 스냅샷을 촬영하면 동일한 고유 ID를 갖게 된다는 점에 유의하십시오. MBR은 디스크 서명을 사용하고 GPT는 GUID(글로벌 고유 식별자)를 사용합니다. 독립 실행형 Hyper-V 호스트의 경우 FlexClone 볼륨을 충돌 없이 쉽게 마운트할 수 있습니다. 이는 독립 실행형 Hyper-V 서버가 자동으로 중복 디스크 ID를 감지하고 사용자 개입 없이 동적으로 변경할 수 있기 때문입니다. 이 접근 방식을 사용하면 시나리오 요구에 따라 VHD를 복제하여 VM을 복구할 수 있습니다.

독립 실행형 Hyper-V 호스트에서는 간단하지만 Hyper-V 클러스터에서는 절차가 다릅니다. 복구 프로세스에는 FlexClone 볼륨을 독립 실행형 Hyper-V 호스트에 매핑하거나 diskpart를 사용하여 FlexClone 볼륨을 독립 실행형 Hyper-V 호스트에 매핑하여 수동으로 서명을 변경하는 작업이 포함됩니다(디스크 ID 충돌로 인해 디스크를 온라인 상태로 전환할 수 없기 때문에 중요). 이 작업을 마치면 FlexClone 볼륨을 클러스터에 매핑합니다.

====
.타사 솔루션을 사용한 백업 및 복원
[%collapsible]
====

NOTE: 이 섹션에서는 Commvault를 사용하지만 다른 타사 솔루션에 적용할 수 있습니다.

CommVault IntelliSnap ® 은 ONTAP 스냅샷을 활용하여 하드웨어 기반 스냅샷을 생성합니다
Hyper-V를 지원합니다 백업은 Hyper-V 하이퍼바이저 또는 VM 그룹의 구성에 따라 자동화되거나 VM 그룹 또는 특정 VM에 대해 수동으로 자동화될 수 있습니다. IntelliSnap을 사용하면 운영 가상화 팜에 최소한의 부하를 가하는 Hyper-V 환경을 신속하게 보호할 수 있습니다. IntelliSnap 기술을 VSA(가상 서버 에이전트)와 통합하면 NetApp ONTAP 스토리지에서 수 분 안에 많은 수의 가상 시스템 및 데이터 저장소를 사용하여 백업을 완료할 수 있습니다. 세분화된 액세스는 전체 게스트 .vhd 파일과 함께 스토리지의 보조 계층에서 개별 파일 및 폴더 복구를 제공합니다.

가상화 환경을 구성하기 전에 스토리지와의 스냅샷 통합이 필요한 적절한 에이전트를 배포합니다. Microsoft Hyper-V 가상화 환경에는 다음 에이전트가 필요합니다.

* MediaAgent를 선택합니다
* 가상 서버 에이전트(VSA)
* VSS 하드웨어 공급자(Windows Server 2012 이상 운영 체제)


*어레이 관리를 사용하여 NetApp 어레이 구성*

다음 단계에서는 ONTAP 스토리지 및 Hyper-V를 사용하는 환경에서 IntelliSnap 가상 머신 백업을 구성하는 방법을 보여 줍니다

. CommCell Console의 리본 메뉴에서 저장소 탭을 클릭한 다음 배열 관리를 클릭합니다.
. Array Management 대화상자가 나타납니다.
. 추가 를 클릭합니다.
+
Array Properties 대화 상자가 나타납니다.

+
image:hyperv-deploy-image09.png["Array Properties(어레이 속성) 대화 상자의 이미지"]

. 일반 탭에서 다음 정보를 지정합니다.
. 스냅 공급업체 목록에서 NetApp를 선택합니다.
. 이름 상자에 기본 파일 서버의 호스트 이름, FQDN(정규화된 도메인 이름) 또는 TCP/IP 주소를 입력합니다.
. 어레이 액세스 노드 탭에서 사용 가능한 미디어 에이전트를 선택합니다.
. 스냅 구성 탭에서 필요에 따라 스냅샷 구성 속성을 구성합니다.
. 확인 을 클릭합니다.
. <Mandatory step>가 완료되면 감지 옵션을 사용하여 NetApp 스토리지 어레이에 SVM을 구성한 다음, SVM을 선택하고 추가 옵션을 사용하여 CommServe 데이터베이스에 SVM을 어레이 관리 항목으로 추가합니다.
+
image:hyperv-deploy-image10.png["SVM을 어레이 관리 항목으로 구성하는 이미지"]

. 고급(아래 그림 참조)을 클릭하고 “IntelliSnap 사용” 확인란을 선택합니다.
+
image:hyperv-deploy-image11.png["IntelliSnap 사용 옵션을 표시하는 이미지입니다"]



배열 구성에 대한 자세한 단계는 를 참조하십시오 link:https://documentation.commvault.com/11.20/configuring_netapp_array_using_array_management.html["NetApp 어레이 구성 중"] 및 link:https://cvdocssaproduction.blob.core.windows.net/cvdocsproduction/2023e/expert/configuring_storage_virtual_machines_on_netapp_arrays.html["NetApp 스토리지에서 스토리지 가상 머신 구성"]

* 하이퍼바이저로 Hyper-V 추가 *

다음 단계는 Hyper-V 하이퍼바이저를 추가하고 VM 그룹을 추가하는 것입니다.

전제 조건:

* 하이퍼바이저는 Hyper-V 클러스터, 클러스터의 Hyper-V 서버 또는 독립 실행형 Hyper-V 서버가 될 수 있습니다.
* 사용자는 Hyper-V Server 2012 이상에 대한 Hyper-V 관리자 그룹에 속해야 합니다. Hyper-V 클러스터의 경우 사용자 계정에 전체 클러스터 권한(읽기 및 모든 권한)이 있어야 합니다.
* 백업 및 복구 작업을 위한 액세스 노드(VSA 프록시)를 생성하기 위해 VSA(Virtual Server Agent)를 설치할 노드를 하나 이상 식별합니다. Hyper-V 서버를 검색하려면 CommServe 시스템에 VSA가 설치되어 있어야 합니다.
* Hyper-V 2012 R2에 대해 변경 블록 추적을 사용하려면 Hyper-V 클러스터의 모든 노드를 선택합니다.


다음 단계에서는 Hyper-V를 하이퍼바이저로 추가하는 방법을 보여 줍니다.

. 핵심 설정이 완료되면 보호 탭에서 가상화 타일을 클릭합니다.
. 서버 백업 계획 생성 페이지에서 계획의 이름을 입력한 다음 스토리지, 보존 및 백업 일정에 대한 정보를 제공합니다.
. 이제 하이퍼바이저 추가 페이지가 나타납니다. > 공급업체 선택: Hyper-V를 선택합니다(IP 주소 또는 FQDN 및 사용자 자격 증명 입력).
. Hyper-V 서버의 경우 노드 검색 을 클릭합니다. Nodes 필드가 채워지면 Virtual Server Agent를 설치할 노드를 하나 이상 선택합니다.
+
image:hyperv-deploy-image12.png["Hyper-V 노드의 검색을 표시하는 이미지입니다"]

. 다음 을 클릭하고 저장 을 클릭합니다.
+
image:hyperv-deploy-image13.png["이전 단계의 결과를 보여주는 이미지입니다"]

. VM 그룹 추가 페이지에서 보호할 가상 머신(이 경우 Demogrp가 생성된 VM 그룹)을 선택하고 아래와 같이 IntelliSnap 옵션을 활성화합니다.
+
image:hyperv-deploy-image14.png["보호할 VM 선택을 보여 주는 이미지입니다"]

+

NOTE: VM 그룹에서 IntelliSnap이 활성화되면 Commvault에서 운영(스냅) 및 백업 복사본에 대한 스케줄 정책을 자동으로 생성합니다.

. 저장 을 클릭합니다.


배열 구성에 대한 자세한 단계는 를 참조하십시오 link:https://documentation.commvault.com/2023e/essential/guided_setup_for_hyper_v.html["하이퍼바이저 추가"].

* 백업 수행: *

. 탐색 창에서 보호 > 가상화 로 이동합니다. Virtual Machines 페이지가 나타납니다.
. VM 또는 VM 그룹을 백업합니다. 이 데모에서는 VM 그룹이 선택되어 있습니다. VM 그룹 행에서 ACTION 버튼 ACTION_BUTTON 을 클릭한 다음 Back Up 을 선택합니다. 이 경우, nimpan Demogrp 및 Demogrp01에 대한 관련 된 계획입니다.
+
image:hyperv-deploy-image15.png["백업할 VM을 선택하는 대화 상자를 보여 주는 이미지입니다"]

. 백업이 성공하면 화면 캡처와 같이 복원 지점을 사용할 수 있습니다. 스냅 복제본에서 전체 VM을 복구하고 게스트 파일 및 폴더를 복구할 수 있습니다.
+
image:hyperv-deploy-image16.png["백업의 복구 지점을 표시하는 이미지입니다"]

+

NOTE: 중요하고 활용도가 높은 가상 시스템의 경우 CSV당 유지 가상 시스템의 수를 줄입니다



* 복원 작업 수행: *

복원 지점을 통해 전체 VM, 게스트 파일 및 폴더 또는 가상 디스크 파일을 복원합니다.

. 탐색 창에서 보호 > 가상화 로 이동하면 가상 머신 페이지가 나타납니다.
. VM Groups 탭을 클릭합니다.
. VM 그룹 페이지가 나타납니다.
. VM 그룹 영역에서 가상 머신이 포함된 VM 그룹에 대해 복구 를 클릭합니다.
. 복원 유형 선택 페이지가 나타납니다.
+
image:hyperv-deploy-image17.png["백업의 복구 유형을 보여 주는 이미지입니다"]

. 선택 항목에 따라 Guest files(게스트 파일) 또는 Full virtual machine(전체 가상 머신) 을 선택하고 복구를 트리거합니다.
+
image:hyperv-deploy-image18.png["복구 옵션을 표시하는 이미지입니다"]



지원되는 모든 복원 옵션에 대한 자세한 단계는 를 참조하십시오 link:https://documentation.commvault.com/2023e/essential/restores_for_hyper_v.html["Hyper-V 복원"].

====


=== 고급 NetApp ONTAP 옵션

NetApp SnapMirror는 효율적인 사이트 간 스토리지 복제를 지원하여 재해 복구를 수행합니다
오늘날의 글로벌 기업에 적합한 빠르고 안정적이며 관리 용이성을 제공합니다. LAN 및 WAN을 통해 데이터를 고속으로 복제하는 SnapMirror는 미션 크리티컬 애플리케이션에 대한 높은 데이터 가용성과 빠른 복구를 제공할 뿐만 아니라 뛰어난 스토리지 중복 제거 및 네트워크 압축 기능도 제공합니다. NetApp SnapMirror 기술을 사용하여 재해 복구로 전체 데이터 센터를 보호할 수 있습니다. 볼륨을 오프사이트 위치에 점차적으로 백업할 수 있습니다. SnapMirror는 필요한 RPO에 따라 증분 블록 기반 복제를 수행합니다. 블록 레벨 업데이트를 통해 대역폭 및 시간 요구사항을 줄이고 DR 사이트에서 데이터 정합성을 유지할 수 있습니다.

중요한 단계는 전체 데이터세트의 1회 베이스라인 전송을 생성하는 것입니다. 이 작업은 증분 업데이트를 수행하기 전에 필요합니다. 이 작업에는 소스에 스냅샷 복사본 생성 및 이 작업이 참조하는 모든 데이터 블록의 전송이 포함됩니다. 초기화가 완료된 후 예약 또는 수동으로 트리거된 업데이트가 발생할 수 있습니다. 각 업데이트는 소스에서 대상 파일 시스템으로 새 블록과 변경된 블록만 전송합니다. 이 작업에는 소스 볼륨에서 스냅샷 복사본 생성, 기본 복사본과 비교, 변경된 블록만 타겟 볼륨으로 전송하는 작업이 포함됩니다. 새 복사본이 다음 업데이트를 위한 베이스라인 복사본이 됩니다. 복제는 주기적인 복제이므로 SnapMirror는 변경된 블록을 통합하고 네트워크 대역폭을 절약할 수 있습니다. 쓰기 처리량과 쓰기 지연 시간에 미치는 영향은 미미합니다.

복구는 다음 단계를 완료하여 수행합니다.

. 보조 사이트의 스토리지 시스템에 접속합니다.
. SnapMirror 관계 중단하기
. SnapMirror 볼륨의 LUN을 2차 사이트의 Hyper-V 서버에 대한 이니시에이터 그룹(igroup)에 매핑합니다.
. LUN이 Hyper-V 클러스터에 매핑되면 해당 디스크를 온라인 상태로 만듭니다.
. failover-cluster PowerShell cmdlet을 사용하여 디스크를 사용 가능한 스토리지에 추가하고 CSV로 변환합니다.
. CSV의 가상 머신을 Hyper-V 관리자로 가져와 고가용성 상태로 만든 다음 클러스터에 추가합니다.
. VM을 켭니다.




== 결론

ONTAP는 다양한 IT 워크로드를 구축할 수 있는 최적의 공유 스토리지 기반입니다. ONTAP AFF 또는 ASA 플랫폼은 여러 사용 사례 및 애플리케이션을 위해 유연하고 확장성이 뛰어납니다. 이 문서에서 사용되는 Windows Server 2022 및 Hyper-V는 가상화 솔루션의 일반적인 사용 사례로서, 이 가이드에 설명되어 있습니다. ONTAP 스토리지 및 관련 기능의 유연성 및 확장성을 통해 고객은 변화하는 비즈니스 요구사항에 맞춰 확장 및 조정할 수 있는 적절한 규모의 스토리지 계층을 먼저 확보할 수 있습니다. 현재 시장 조건에서 Hyper-V는 VMware에서 제공하는 대부분의 기능을 제공하는 완벽한 대체 하이퍼바이저 옵션을 제공합니다.



== 부록 A: FlexClone 및 PowerShell을 사용한 마이그레이션

.PowerShell 스크립트
[%collapsible]
====
[source, powershell]
----
param (
    [Parameter(Mandatory=$True, HelpMessage="VCenter DNS name or IP Address")]
    [String]$VCENTER,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP NFS Datastore name")]
    [String]$DATASTORE,
    [Parameter(Mandatory=$True, HelpMessage="VCenter credentials")]
    [System.Management.Automation.PSCredential]$VCENTER_CREDS,
    [Parameter(Mandatory=$True, HelpMessage="The IP Address of the ONTAP Cluster")]
    [String]$ONTAP_CLUSTER,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP VServer/SVM name")]
    [String]$VSERVER,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP NSF,SMB Volume name")]
    [String]$ONTAP_VOLUME_NAME,
    [Parameter(Mandatory=$True, HelpMessage="ONTAP NFS/CIFS Volume mount Drive on Hyper-V host")]
    [String]$ONTAP_NETWORK_SHARE_ADDRESS,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP Volume QTree folder name")]
    [String]$VHDX_QTREE_NAME,
    [Parameter(Mandatory=$True, HelpMessage="The Credential to connect to the ONTAP Cluster")]
    [System.Management.Automation.PSCredential]$ONTAP_CREDS,
    [Parameter(Mandatory=$True, HelpMessage="Hyper-V VM switch name")]
    [String]$HYPERV_VM_SWITCH
)

function main {

    ConnectVCenter

    ConnectONTAP

    GetVMList

    GetVMInfo

    #PowerOffVMs

    CreateOntapVolumeSnapshot

    Shift

    ConfigureVMsOnHyperV
}

function ConnectVCenter {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Connecting to vCenter $VCENTER" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    [string]$vmwareModuleName = "VMware.VimAutomation.Core"

    Write-Host "Importing VMware $vmwareModuleName Powershell module"
    if ((Get-Module|Select-Object -ExpandProperty Name) -notcontains $vmwareModuleName) {
        Try {
            Import-Module $vmwareModuleName -ErrorAction Stop
            Write-Host "$vmwareModuleName imported successfully" -ForegroundColor Green
        } Catch {
            Write-Error "Error: $vmwareMdouleName PowerShell module not found"
			break;
        }
    }
    else {
        Write-Host "$vmwareModuleName Powershell module already imported" -ForegroundColor Green
    }

    Write-Host "`nConnecting to vCenter $VCENTER"
    Try {
        $connect = Connect-VIServer -Server $VCENTER -Protocol https -Credential $VCENTER_CREDS -ErrorAction Stop
        Write-Host "Connected to vCenter $VCENTER" -ForegroundColor Green
    } Catch {
        Write-Error "Failed to connect to vCenter $VCENTER. Error : $($_.Exception.Message)"
		break;
    }
}

function ConnectONTAP {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Connecting to VSerevr $VSERVER at ONTAP Cluster $ONTAP_CLUSTER" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    [string]$ontapModuleName = "NetApp.ONTAP"

    Write-Host "Importing NetApp ONTAP $ontapModuleName Powershell module"
    if ((Get-Module|Select-Object -ExpandProperty Name) -notcontains $ontapModuleName) {
        Try {
            Import-Module $ontapModuleName -ErrorAction Stop
            Write-Host "$ontapModuleName imported successfully" -ForegroundColor Green
        } Catch {
            Write-Error "Error: $vmwareMdouleName PowerShell module not found"
			break;
        }
    }
    else {
        Write-Host "$ontapModuleName Powershell module already imported" -ForegroundColor Green
    }

    Write-Host "`nConnecting to ONTAP Cluster $ONTAP_CLUSTER"
    Try {
        $connect = Connect-NcController -Name $ONTAP_CLUSTER -Credential $ONTAP_CREDS -Vserver $VSERVER
        Write-Host "Connected to ONTAP Cluster $ONTAP_CLUSTER" -ForegroundColor Green
    } Catch {
        Write-Error "Failed to connect to ONTAP Cluster $ONTAP_CLUSTER. Error : $($_.Exception.Message)"
		break;
    }
}

function GetVMList {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Fetching powered on VMs list with Datastore $DATASTORE" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan
    try {
        $vmList = VMware.VimAutomation.Core\Get-VM -Datastore $DATASTORE -ErrorAction Stop| Where-Object {$_.PowerState -eq "PoweredOn"} | OUT-GridView -OutputMode Multiple
        #$vmList = Get-VM -Datastore $DATASTORE -ErrorAction Stop| Where-Object {$_.PowerState -eq "PoweredOn"}

        if($vmList) {
            Write-Host "Selected VMs for Shift" -ForegroundColor Green
            $vmList | Format-Table -Property Name
            $Script:VMList = $vmList
        }
        else {
            Throw "No VMs selected"
        }
    }
    catch {
        Write-Error "Failed to get VM List. Error : $($_.Exception.Message)"
        Break;
    }
}

function GetVMInfo {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "VM Information" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    $vmObjArray = New-Object System.Collections.ArrayList

    if($VMList) {
        foreach($vm in $VMList) {
            $vmObj = New-Object -TypeName System.Object

            $vmObj | Add-Member -MemberType NoteProperty -Name ID -Value $vm.Id
            $vmObj | Add-Member -MemberType NoteProperty -Name Name -Value $vm.Name
            $vmObj | Add-Member -MemberType NoteProperty -Name NumCpu -Value $vm.NumCpu
            $vmObj | Add-Member -MemberType NoteProperty -Name MemoryGB -Value $vm.MemoryGB
            $vmObj | Add-Member -MemberType NoteProperty -Name Firmware -Value $vm.ExtensionData.Config.Firmware

            $vmDiskInfo = $vm | VMware.VimAutomation.Core\Get-HardDisk

            $vmDiskArray = New-Object System.Collections.ArrayList
            foreach($disk in $vmDiskInfo) {
                $diskObj = New-Object -TypeName System.Object

                $diskObj | Add-Member -MemberType NoteProperty -Name Name -Value $disk.Name

                $fileName = $disk.Filename
                if ($fileName -match '\[(.*?)\]') {
                    $dataStoreName = $Matches[1]
                }

                $parts = $fileName -split " "
                $pathParts = $parts[1] -split "/"
                $folderName = $pathParts[0]
                $fileName = $pathParts[1]

                $diskObj | Add-Member -MemberType NoteProperty -Name DataStore -Value $dataStoreName
                $diskObj | Add-Member -MemberType NoteProperty -Name Folder -Value $folderName
                $diskObj | Add-Member -MemberType NoteProperty -Name Filename -Value $fileName
                $diskObj | Add-Member -MemberType NoteProperty -Name CapacityGB -Value $disk.CapacityGB

                $null = $vmDiskArray.Add($diskObj)
            }

            $vmObj | Add-Member -MemberType NoteProperty -Name PrimaryHardDisk -Value "[$($vmDiskArray[0].DataStore)] $($vmDiskArray[0].Folder)/$($vmDiskArray[0].Filename)"
            $vmObj | Add-Member -MemberType NoteProperty -Name HardDisks -Value $vmDiskArray

            $null = $vmObjArray.Add($vmObj)

            $vmNetworkArray = New-Object System.Collections.ArrayList

            $vm |
            ForEach-Object {
              $VM = $_
              $VM | VMware.VimAutomation.Core\Get-VMGuest | Select-Object -ExpandProperty Nics |
              ForEach-Object {
                $Nic = $_
                foreach ($IP in $Nic.IPAddress)
                {
                  if ($IP.Contains('.'))
                  {
                    $networkObj = New-Object -TypeName System.Object

                    $vlanId = VMware.VimAutomation.Core\Get-VirtualPortGroup | Where-Object {$_.Key -eq $Nic.NetworkName}
                    $networkObj | Add-Member -MemberType NoteProperty -Name VLanID -Value $vlanId
                    $networkObj | Add-Member -MemberType NoteProperty -Name IPv4Address -Value $IP

                    $null = $vmNetworkArray.Add($networkObj)
                  }
                }
              }
            }

            $vmObj | Add-Member -MemberType NoteProperty -Name PrimaryIPv4 -Value $vmNetworkArray[0].IPv4Address
            $vmObj | Add-Member -MemberType NoteProperty -Name PrimaryVLanID -Value $vmNetworkArray.VLanID
            $vmObj | Add-Member -MemberType NoteProperty -Name Networks -Value $vmNetworkArray

            $guest = $vm.Guest
            $parts = $guest -split ":"
            $afterColon = $parts[1]

            $osFullName = $afterColon

            $vmObj | Add-Member -MemberType NoteProperty -Name OSFullName -Value $osFullName
            $vmObj | Add-Member -MemberType NoteProperty -Name GuestID -Value $vm.GuestId
        }
    }

    $vmObjArray | Format-Table -Property ID, Name, NumCpu, MemoryGB, PrimaryHardDisk, PrimaryIPv4, PrimaryVLanID, GuestID, OSFullName, Firmware

    $Script:VMObjList = $vmObjArray
}

function PowerOffVMs {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Power Off VMs" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan
    foreach($vm in $VMObjList) {
        try {
            Write-Host "Powering Off VM $($vm.Name) in vCenter $($VCENTER)"
            $null = VMware.VimAutomation.Core\Stop-VM -VM $vm.Name -Confirm:$false -ErrorAction Stop
            Write-Host "Powered Off VM $($vm.Name)" -ForegroundColor Green
        }
        catch {
            Write-Error "Failed to Power Off VM $($vm.Name). Error : $._Exception.Message"
            Break;
        }
        Write-Host "`n"
    }
}

function CreateOntapVolumeSnapshot {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Taking ONTAP Snapshot for Volume $ONTAP_VOLUME_NAME" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    Try {
        Write-Host "Taking snapshot for Volume $ONTAP_VOLUME_NAME"
        $timestamp = Get-Date -Format "yyyy-MM-dd_HHmmss"
        $snapshot = New-NcSnapshot -VserverContext $VSERVER -Volume $ONTAP_VOLUME_NAME -Snapshot "snap.script-$timestamp"

        if($snapshot) {
            Write-Host "Snapshot ""$($snapshot.Name)"" created for Volume $ONTAP_VOLUME_NAME" -ForegroundColor Green
            $Script:OntapVolumeSnapshot = $snapshot
        }
    } Catch {
        Write-Error "Failed to create snapshot for Volume $ONTAP_VOLUME_NAME. Error : $_.Exception.Message"
        Break;
    }
}

function Shift {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "VM Shift" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    $Script:HypervVMList = New-Object System.Collections.ArrayList
    foreach($vmObj in $VMObjList) {

        Write-Host "***********************************************"
        Write-Host "Performing VM conversion for $($vmObj.Name)" -ForegroundColor Blue
        Write-Host "***********************************************"

        $hypervVMObj = New-Object -TypeName System.Object

        $directoryName = "/vol/$($ONTAP_VOLUME_NAME)/$($VHDX_QTREE_NAME)/$($vmObj.HardDisks[0].Folder)"

        try {
            Write-Host "Creating Folder ""$directoryName"" for VM $($vmObj.Name)"
            $dir = New-NcDirectory -VserverContext $VSERVER -Path $directoryName -Permission 0777 -Type directory -ErrorAction Stop
            if($dir) {
                Write-Host "Created folder ""$directoryName"" for VM $($vmObj.Name)`n" -ForegroundColor Green
            }
        }
        catch {
            if($_.Exception.Message -eq "[500]: File exists") {
                Write-Warning "Folder ""$directoryName"" already exists!`n"
            }
            Else {
                Write-Error "Failed to create folder ""$directoryName"" for VM $($vmObj.Name). Error : $($_.Exception.Message)"
                Break;
            }
        }

        $vmDiskArray = New-Object System.Collections.ArrayList

        foreach($disk in $vmObj.HardDisks) {
            $vmDiskObj = New-Object -TypeName System.Object
            try {
                Write-Host "`nConverting $($disk.Name)"
                Write-Host "--------------------------------"

                $vmdkPath = "/vol/$($ONTAP_VOLUME_NAME)/$($disk.Folder)/$($disk.Filename)"
                $fileName = $disk.Filename -replace '\.vmdk$', ''
                $vhdxPath = "$($directoryName)/$($fileName).vhdx"

                Write-Host "Converting ""$($disk.Name)"" VMDK path ""$($vmdkPath)"" to VHDX at Path ""$($vhdxPath)"" for VM $($vmObj.Name)"
                $convert = ConvertTo-NcVhdx -SourceVmdk $vmdkPath -DestinationVhdx $vhdxPath  -SnapshotName $OntapVolumeSnapshot -ErrorAction Stop -WarningAction SilentlyContinue
                if($convert) {
                    Write-Host "Successfully converted VM ""$($vmObj.Name)"" VMDK path ""$($vmdkPath)"" to VHDX at Path ""$($vhdxPath)""" -ForegroundColor Green

                    $vmDiskObj | Add-Member -MemberType NoteProperty -Name Name -Value $disk.Name
                    $vmDiskObj | Add-Member -MemberType NoteProperty -Name VHDXPath -Value $vhdxPath

                    $null = $vmDiskArray.Add($vmDiskObj)
                }
            }
            catch {
                Write-Error "Failed to convert ""$($disk.Name)"" VMDK to VHDX for VM $($vmObj.Name). Error : $($_.Exception.Message)"
                Break;
            }
        }

        $hypervVMObj | Add-Member -MemberType NoteProperty -Name Name -Value $vmObj.Name
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name HardDisks -Value $vmDiskArray
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name MemoryGB -Value $vmObj.MemoryGB
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name Firmware -Value $vmObj.Firmware
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name GuestID -Value $vmObj.GuestID



        $null = $HypervVMList.Add($hypervVMObj)
        Write-Host "`n"

    }
}

function ConfigureVMsOnHyperV {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Configuring VMs on Hyper-V" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    foreach($vm in $HypervVMList) {
        try {

            # Define the original path
            $originalPath = $vm.HardDisks[0].VHDXPath
            # Replace forward slashes with backslashes
            $windowsPath = $originalPath -replace "/", "\"

            # Replace the initial part of the path with the Windows drive letter
            $windowsPath = $windowsPath -replace "^\\vol\\", "\\$($ONTAP_NETWORK_SHARE_ADDRESS)\"

            $vmGeneration = if ($vm.Firmware -eq "bios") {1} else {2};

            Write-Host "***********************************************"
            Write-Host "Creating VM $($vm.Name)" -ForegroundColor Blue
            Write-Host "***********************************************"
            Write-Host "Creating VM $($vm.Name) with Memory $($vm.MemoryGB)GB, vSwitch $($HYPERV_VM_SWITCH), $($vm.HardDisks[0].Name) ""$($windowsPath)"", Generation $($vmGeneration) on Hyper-V"

            $createVM = Hyper-V\New-VM -Name $vm.Name -VHDPath $windowsPath -SwitchName $HYPERV_VM_SWITCH -MemoryStartupBytes (Invoke-Expression "$($vm.MemoryGB)GB") -Generation $vmGeneration -ErrorAction Stop
            if($createVM) {
                Write-Host "VM $($createVM.Name) created on Hyper-V host`n" -ForegroundColor Green


                $index = 0
                foreach($vmDisk in $vm.HardDisks) {
                    $index++
                    if ($index -eq 1) {
                        continue
                    }

                    Write-Host "`nAttaching $($vmDisk.Name) for VM $($vm.Name)"
                    Write-Host "---------------------------------------------"

                    $originalPath = $vmDisk.VHDXPath

                    # Replace forward slashes with backslashes
                    $windowsPath = $originalPath -replace "/", "\"

                    # Replace the initial part of the path with the Windows drive letter
                    $windowsPath = $windowsPath -replace "^\\vol\\", "\\$($ONTAP_NETWORK_SHARE_ADDRESS)\"

                    try {
                        $attachDisk = Hyper-v\Add-VMHardDiskDrive -VMName $vm.Name -Path $windowsPath -ErrorAction Stop
                        Write-Host "Attached $($vmDisk.Name) ""$($windowsPath)"" to VM $($vm.Name)" -ForegroundColor Green
                    }
                    catch {
                        Write-Error "Failed to attach $($vmDisk.Name) $($windowsPath) to VM $($vm.Name): Error : $($_.Exception.Message)"
                        Break;
                    }
                }

                if($vmGeneration -eq 2 -and $vm.GuestID -like "*rhel*") {
                    try {
                        Write-Host "`nDisabling secure boot"
                        Hyper-V\Set-VMFirmware -VMName $createVM.Name -EnableSecureBoot Off -ErrorAction Stop
                        Write-Host "Secure boot disabled" -ForegroundColor Green
                    }
                    catch {
                        Write-Error "Failed to disable secure boot for VM $($createVM.Name). Error : $($_.Exception.Message)"
                    }
                }

                try {
                    Write-Host "`nStarting VM $($createVM.Name)"
                    Hyper-v\Start-VM -Name $createVM.Name -ErrorAction Stop
                    Write-Host "Started VM $($createVM.Name)`n" -ForegroundColor Green
                }
                catch {
                    Write-Error "Failed to start VM $($createVM.Name). Error : $($_.Exception.Message)"
                    Break;
                }
            }
        }
        catch {
            Write-Error "Failed  to create VM $($vm.Name) on Hyper-V. Error : $($_.Exception.Message)"
            Break;
        }
    }
}

main
----
====